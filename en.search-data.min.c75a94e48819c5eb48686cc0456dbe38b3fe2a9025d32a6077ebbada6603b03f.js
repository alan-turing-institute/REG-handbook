"use strict";(function(){const t={cache:!0};t.doc={id:"id",field:["title","content"],store:["title","href","section"]};const e=FlexSearch.create("balance",t);window.bookSearchIndex=e,e.add({id:0,href:"/REG-handbook/docs/contributing/discussions_and_issues/",title:"Discussions and Issues",section:"Contributing",content:` Discussions and Issues # Contributing does not only mean adding code or writing pages. Being involved in reporting issues and discussing ideas are important and valuable aspects to contributing. The handbook uses both issues and discussions on GitHub.
Discussions # The handbook Dicussions are the best place for informal talk about the handbook.
You should feel welcome to create a discussion on any relevant topic, without the formality of an issue.
Good examples of discussions are
Any questions Possible bugs (does anyone else have this problem?) Chapter suggestions Looking for collaborators Community support Any other on-topic talk Issues # The issue tracker is best used for development work. This is because issues integrate well with GitHub development tools like projects, pull requests, assignments and so on.
Each issue should ideally represent a well-defined, self-contained piece of work suitable to become a single pull request.
Good examples of issues are
Bug reports with technical detail Developed chapter proposals Feature requests (such as new shortcodes) Specific ideas for changes When opening an issue, pick a suitable template (if any) to make the process easier.
`}),e.add({id:1,href:"/REG-handbook/docs/onboarding/buddy_system/",title:"Buddy System",section:"Onboarding",content:` Buddy System # It can be daunting starting a new job, especially remotely where there is sometimes less opportunity for casual questions. To help with this every new employee should be assigned buddies. The buddies are responsible for providing informal friendly faces to offer advice, guidance, and encouragement on any aspect of working within REG and ARC.
We also emphasise that the buddies should be a safe space where new-starters can get help with any technical questions that they feel is silly or trivially easy and may not feel comfortable admitting to the wider group.
The Process # Before the new starter starts at the Turing they should be assigned two buddies from our buddy pool. If possible, the buddies should not be assigned to the projects on which the new starter is likely to work, and ideally at a similarly seniority to the new starter.
We would also like for each new starter to have a third buddy from some other team. We think that in a remote \u0026amp; hybrid setting it will help new-starters meet people and get a feel for the wider Turing ecosystem. This has been trialed in a few instances, to positive feedback, but to make this be standard practice we would need it to be more bidirectional, with REGers volunteering to buddy with people outside of REG.
The new-starter should be made aware of the buddies\u0026rsquo; role before they start, and meeting their buddies should typically be the first appointment on their first day.
The buddy system in managed by the person in charge of onboarding.
Buddy Guidelines # Have a coffee with the new employee on their first day. If needed, introduce them to the team at welcome coffee. Be as informal as possible, make the new starter feel welcome and comfortable. Make sure the new starter is familiar with the New Starter page. Check for sticking points. Meet the new starter where they are at. Make it clear that the new employee can get in touch any time for questions and concerns, regardless of triviality. Emphasise that you\u0026rsquo;re also there for technical pointers. This is to encourage the new-starter to be comfortable asking for help when they are stuck and hopefully lessening imposter syndrome anxiety. Have a check-in chat with the new starter at least once in the first couple of weeks, and again a few weeks after. During these check-ins, uncover pain points and concerns. Help socialise the new employee to the group\u0026rsquo;s culture and processes. Be open, honest, and respect confidentiality. If needed, help make introductions. Tips for Buddies # Don’t worry about being perceived as the expert. Focus your attention on the new employee. Be patient: It takes time to develop a relationship. Don’t try to cover everything right away. Be positive: New employees will grow into their roles if given proper reinforcement. Don’t try to force a relationship. New employees will vary in how much they turn to a buddy. Try to identify the new employee’s personality and communication style and adapt accordingly. Don’t be judgemental. Simply offer feedback. Maintain a good attitude and a teaching spirit. How to be a Buddy # Being a buddy can be a rewarding process. You will help avoid new starters feeling at sea and reaffirm their decision to join the group. To sign up please add your name to our buddy pool.
`}),e.add({id:2,href:"/REG-handbook/docs/regular_events/coffee_chats/",title:"Coffee Chats",section:"Regular Events",content:` Coffee Chats # The team has two optional, daily coffee chats at 08:45 and 13:45. The chats usually happen in Gather but there is also a Zoom room in case Gather is unavailable. Details for both rooms can be found here.
`}),e.add({id:3,href:"/REG-handbook/docs/regular_events/drop-in_sessions/",title:"Drop-in Sessions",section:"Regular Events",content:` Drop-in Sessions # The group runs regular, informal, community-led sessions for students and researchers. At the sessions they can ask the group about specific technical problems, or seek general technical advice. The sessions offer a friendly, welcoming, non-judgemental environment to receive advice or assistance without concern about being judged on technical knowledge, expertise or understanding.
As our organisers and helpers know, many of us working with software in the research community have been trained in domains where computing has not traditionally been a key element. There can be lots to learn in terms of new jargon and technical skills and we all have to start somewhere.
We can help with:
General programming problems — including helping to identify and fix bugs. Cloud computing questions — including how to get started on Azure. Software sustainability — best practices for testing, managing and packaging your code. Reproducible research — ensuring software is developed to support long-term reproducibility, including techniques for packaging and archiving code. High Performance Computing (HPC) — support and advice on the HPC resources available at the Turing. Joining sessions # Our weekly sessions run for one hour from 13:30-14:30 every Tuesday and are hosted on Zoom. Everyone is welcome to drop-in at any time. There is no need to register in advance.
`}),e.add({id:4,href:"/REG-handbook/docs/onboarding/new_joiners/first_few_days/",title:"First Few Days",section:"New Joiners",content:` First Few Days # Welcome!
We are super pleased that you\u0026rsquo;re joining our group. This page gives you an overview of what to expect from your first few days. They are maintained by the group, we hope that new-starters feel empowered to edit them if there are useful changes to be made.
Introductions # Each new starter gets assigned two buddies to be friendly points of contact. The person in charge of onboarding should let you know who these are a bit before you start; If that doesn\u0026rsquo;t happen, please email them about it. Your buddies will welcome you on the first day. In the first few days there will be a welcome coffee to give you a chance to introduce yourself to the whole REG team, and within the first few weeks you will also have a 1-on-1 meeting with REG\u0026rsquo;s Director.
You will have a week or so before you will be assigned to a project. Please use this time to do admin stuff, set up your laptop and tools, get to know people, read this handbook and our internal wiki, and shadow meetings (see below). Here we go over the main points you should remember to do, but for an attempt at listing all the small tasks that occupy a new starter, please see (and improve!) this checklist.
We also have a page of tables available with information about links and resources related to REG and the Alan Turing Institute.
Administrivia # HR will set up a meeting with you to discuss general information e.g. pay, health, leaves, benefits. IT will also meet you to discuss accounts and Turing wide systems. Both of these will typically take place in the first day or two.
We have a dedicated page for various systems REG uses. Have a look at the high priority section on your first day.
We also have a Remote Working page for Zoom, Teams, and Gather.
REG offers new starters the opportunity to shadow meetings across the group to meet people and get a feel for how we work. The shadowing document should be updated with meetings you are free to come and listen in on, if it hasn\u0026rsquo;t been please bug the person in charge of onboarding.
To access the office you will need a British Library pass. To get a British Library pass you will need to go through the background screening check. Hopefully that process will have been completed by the time you start, but if it hasn\u0026rsquo;t even been started yet (this happens), please talk to HR to make sure the process gets going. Once the screening is done, HR should let you know within a few days that your pass is ready.
In the meanwhile, you can either enter the British Library through the general public entrance and come talk to the Turing\u0026rsquo;s reception, or, preferably, arrange for a visitor pass for yourself for the days when you\u0026rsquo;re coming in. For the first day or two, ask your line manager to take care of this, once you\u0026rsquo;ve got your Turing account going you can directly ask reception.
The password for the \u0026ldquo;ATI Guest\u0026rdquo; Wi-Fi network can be seen hanging around the office. IT can arrange access to the Eduroam network. Eduroam credentials can be used to access Wi-Fi at many academic institutions.
Please also write a short, informal paragraph about your background for to be put into the next REG newsletter, and send it to the newsletter owner.
Overview of How REG Operates # Work at REG revolves around projects and service areas. You will typically be assigned to two different projects at any time, with at least one other REG person and usually some external collaborators. You may want to browse REG\u0026rsquo;s portfolio of projects in the project tracker to get an idea of what we\u0026rsquo;re up to. The project tracker is also used for expressing preferences on which upcoming projects you would like to work on, but you don\u0026rsquo;t have to worry about that for first few weeks. We very much encourage REG members to learn new things, so feel free to choose projects that sound interesting to you even if they are unfamiliar. Check this section of the handbook for more details.
Service areas are REG-internal work, such as looking after this handbook, organising recruitment, or managing our computational resources. Usually people contribute to one service area, which should take approximately half a day a week. This, too, is something you don\u0026rsquo;t have to think about for now, but come back to it once you\u0026rsquo;ve settled into your workflow with a project.
REG also gives its members some time, known as 22 days time, to work on side projects they find interesting. Your line manager can give you the details on this.
If you like, you can see our team reporting structure. Note, however, that we do not have a hierarchical culture, and line managing relations are not about assigning work to people. Your work tasks will be coordinated with the people in your projects.
You should talk to your line manager about things such as
How project allocation works, and what kinds of projects you would like to work on Managing your time and growth How we work (practices, tools, languages, etc.) How you would like to grow and develop in your role and what opportunities exist to support that. Please also take a some time to browse this handbook, it\u0026rsquo;s got plenty of useful information about what we do and how we do it.
Set up Your Machine and Coding Environment # See systems setup.
Regular Events # Check out our regular events and coffee breaks. Please consider signing up for a tech talk sometime in your first six weeks. If you don\u0026rsquo;t see a calendar invite for the weekly tech talks, ask the person in charge of onboarding to add you to the relevant mailing list.
What to do next # If you\u0026rsquo;ve done all the above, read through the handbook and the repo and are still waiting for your first project to start, go and talk to the person in charge of onboarding. They will find something meaningful for you to do which might be something like:
(Optional) Browse the project board and emoji any projects in the Looking for people and Awaiting start columns Note: you will be notified to do this before being assigned to a project Work on a Turing Data Story. There\u0026rsquo;s always a story to join or a new one to start. You can then keep working on it on your 22 days time once allocated to a project. This option has been very popular. Tackle a GitHub issue marked with the good first issue tag in a repo that REG works on. Whenever a new starter is looking for things to do, the person in charge of onboarding will send a message on Slack asking everyone to tag suitable issues. Work on a REG-internal project that is easy to rotate in/out of. Any ad hoc ideas that come up. Maybe you found a project that really interests you and want to help, or maybe there\u0026rsquo;s some team organisational thing that comes up that you volunteer for. Points of Contact # You can find useful points of contact here. This page also holds other useful information such as remote meeting details and team responsibilities.
`}),e.add({id:5,href:"/REG-handbook/docs/contributing/getting_started/",title:"Getting Started",section:"Contributing",content:` Getting Started # Install dependencies # To contribute to the handbook you will need
Git Hugo (You will need the extended version with Sass/SCSS support) Your favourite text editor You might also find it helpful to install markdownlint so that you can lint your branch before making a pull request.
The linting style used is included in the root of the repository, .mdl_style.rb.
Clone the repository # Clone the repository with one of the following options (depending on how you authenticate with GitHub):
SSH authentication git clone --recurse-submodules git@github.com:alan-turing-institute/REG-handbook.git cd REG-handbook HTTPS authentication git clone --recurse-submodules https://github.com/alan-turing-institute/REG-handbook.git cd REG-handbook The --recurse-submodules flag is important as the handbook\u0026rsquo;s theme is included as a Git submodule
Serve the handbook locally # While working on the handbook, it will be useful to preview your changes locally. To do this use Hugo\u0026rsquo;s server command
hugo server --minify In the output of this command will be a line similar to
Web Server is available at http://localhost:1313/REG-handbook/ (bind address 127.0.0.1) which contains the URL of the locally served site. Navigate to this address in your browser to preview the handbook.
The Hugo server will monitor the files in the repository and automatically rebuild the site whenever you make changes. This is a useful tool to immediately view your changes.
`}),e.add({id:6,href:"/REG-handbook/docs/how_we_work/knowledge_sharing/",title:"Knowledge Sharing",section:"How we work",content:` Knowledge Sharing # This page lists the tools, resources and activities that REG has to promote general communication as well as sharing and gaining knowledge across the team (and the Turing as a whole), and some thoughts on what we could try to improve this. If you\u0026rsquo;re looking to learn something new, get help with a problem, share something cool you\u0026rsquo;ve been doing, or find out what others in the team are doing, the list below may give an idea of where to look/what to try.
If you\u0026rsquo;d like to organise something the best options are usually to post to Slack and the Hut23 mailing list (see below).
Daily # Github Hut23 Repo # We use GitHub (and a couple of related tools) extensively for tracking projects and other tasks within the team. There is a separate page describing how we use them.
Coffee Breaks # We have coffee breaks on Gather twice daily. See the Regular Events page for details. If the times aren\u0026rsquo;t convenient and you fancy a break then try posting on Slack and the chances are that there\u0026rsquo;ll be others that fancy a break too.
Slack # Slack is our main tool for informal messaging and announcements (there\u0026rsquo;s some info on how to join on here). It\u0026rsquo;s also a good place to ask for help. Channels of interest include:
#hut23: Our channel for the REG team (ask someone to add you if you don\u0026rsquo;t have access) #tps: Channel for the tools, practices and systems (TPS) community at the Turing #askaway: Place to ask general questions (e.g. that don\u0026rsquo;t fit in a specific channel) #interesting-events, #general, #social, #random: General chat and announcement about what\u0026rsquo;s happening around the Turing. We use Geekbot, which is a Slack App. We use this in two different ways (both are voluntary):
A virtual daily standup: Geekbot asks what you\u0026rsquo;re planning to do each day, what you\u0026rsquo;ve achieved and if there is anything you are stuck on. This can be useful for your own planning, but also helps give an overview of the range of other work and skills within the team. Ice breaker-style questions a few times a week. To join in with the use of Geekbot, you will need to first add the Geekbot app to Slack and then join these slack channels #hut23standup and #hut23standup-tasks.
Weekly # Tech Talks # See here.
Reading Groups # See here.
Approximately Monthly # REG Team Meetings # Roughly once a month we have an all-REG meeting where we welcome new joiners and a few people briefly present news from around REG or the Turing. This is usually followed by a discussion on a topic of interest for the wider team. If you don\u0026rsquo;t have the calendar invites (new joiners might not initially) ask someone else in the team to forward them to you.
Turing Events # The main focus of this page is what we do in REG, but there are many things happening around the Turing that REG members are also encouraged to attend, including:
Turing Catchups \u0026amp; Town Halls — Regular meetings open to all staff with updates from around the institute. New starters may not have the calendar invites initially — ask others in the team to forward the details if you\u0026rsquo;re unsure. Turing Events - often public talks \u0026amp; workshops. REG Newsletter # We have a monthly REG newsletter which is usually sent around about a week before the monthly team meeting. It contains short project updates and other news/updates from around the team and the institute. It comes to the Hut23 mailing list (see above). If you have something you\u0026rsquo;d like to be included contact the newsletter owner.
Hut23 Mailing List # You should automatically be added to the Hut23@turing.ac.uk mailing list when you join REG (if not ask your line manager about it). This is often the best way to contact everyone in the team when organising events, or for other news/communication that should be a bit more permanent/formal than Slack and doesn\u0026rsquo;t fit in an issue in the Hut23 repo.
Less frequently or ad-hoc # Data study Groups # Data study groups (DSGs) are week-long hack sessions on different projects that happen a few times a year. Participants are drawn from across the Turing and REG people have previously joined both as team members and project PIs.
Turing courses and training # There are professional and academic training opportunities around the Turing. There\u0026rsquo;s some info on Mathison. Additionally, REG also runs a yearly research software engineering course.
Remote Co-working # Occasionally a few REG members get together on Zoom to Gather to do our work (not necessarily to work on the same thing, but to see each other and have a quick chat whilst we\u0026rsquo;re working). During the COVID lockdowns, we organised these sessions regularly. Now they only occur on an ad-hoc basis. If you\u0026rsquo;d like to work in this way, feel free to ask on Slack.
Some project teams also choose to work in this way.
Hack Sessions \u0026amp; REG Collaborative Time # If there\u0026rsquo;s something you\u0026rsquo;d like to work on collaboratively feel free to organise a hack session (typically these would be longer but less frequent than a reading group, and perhaps more focused on implementing rather than reading). In the past several of us have got together to work on contributions for Hacktoberfest.
Repo Audits # A few of us plan to get together to help check whether documentation, usage and installation instructions are clear for a project (for example), or to review the code. See this page for more details.
Project retrospective - Snark Hunts # A \u0026ldquo;Snark Hunt\u0026rdquo; is one way in which we\u0026rsquo;ve previously organised project retrospectives. We\u0026rsquo;re open to trying other ideas too.
Snark hunts are facilitated discussions after a project has finished where the project team, together with others from REG that didn\u0026rsquo;t work on the project, answer/ask questions relating to the experience of working on it — what went well, what could have been better etc.. We don\u0026rsquo;t do it for every project, but they can be a good opportunity to reflect and to get ideas for what we should do differently/do more of in the future. For more info, see here:
Snark Hunt concept Snark Hunt template and example questions Previous Snark Hunts Working on Other Projects # Working on different projects with different people causes a natural sharing of knowledge around the team. Beyond the usual project allocation process, there may be other ways to get involved with another project for a short time (some of these are speculative and not currently common practice in REG):
Rotating between projects: Where a team member has been on a project for a long time, they may wish to change. Team members should ask to rotate to a different project in the next set of project allocations. Gaps between projects: Occasionally there are short gaps between one project finishing and another starting. These can be opportunities to get involved in something different for a while. One example could be to try a project with the ARC team (though I don\u0026rsquo;t think anyone in REG has done this yet). Projects may also want to get into the habit of creating \u0026ldquo;Hacktoberfest\u0026rdquo; style issues that newcomers could quickly get up to speed with and get involved if they have a gap in allocations. Shadowing projects: Especially for new starters, we\u0026rsquo;ve started to encourage the idea of shadowing projects for a short while, to get an idea of how we work. `}),e.add({id:7,href:"/REG-handbook/docs/regular_events/lightning_talks/",title:"Lightning Talks",section:"Regular Events",content:` Lightning Talks # Lightning Talks are a meeting series within the tech talk slots in which people give short 10 minute talks. The main goals are to:
Regularly share what we\u0026rsquo;re working on. Find overlaps between projects or problems someone else in the team could help with. Generate ideas for future tech talks. Do all this without a big time commitment, both for presenters and attendees. The talks can be on any topic, including but not limited to:
A project (including one that hasn\u0026rsquo;t started yet). A tool or technique you use. Something you\u0026rsquo;d like help with. Informal talks or discussions without slides or much preparation are encouraged and very welcome!
Talk Format # Each slot will be 10 minutes with a few minutes after for questions. We will be fairly strict with time to make sure everyone on the agenda gets to present.
You can choose whatever format you like (slides, markdown, notebook, freestyle…), but remember that it\u0026rsquo;s a short slot which lends itself to concise, high-level overviews of a topic. For example, if your talk is on a project you may wish to cover the following:
Background: The domain area, context, problem etc.. Goals: What are the aims of the project? Status: What\u0026rsquo;s been done so far, example results (if any). Tools \u0026amp; Techniques: What you\u0026rsquo;re using, what you\u0026rsquo;ve learnt, what you\u0026rsquo;d like help with. Summary: who\u0026rsquo;s working on the project, dates, GitHub link etc.. If you\u0026rsquo;d like to prepare slides, there\u0026rsquo;s a PowerPoint template and examples from previous talks under here that can help you get started.
Sign Up # To sign up to present a Lightning Talk, please add yourself to the signup list
Previous Talks # You can find a list of previous talks and their slides here.
`}),e.add({id:8,href:"/REG-handbook/docs/regular_events/lunchtime_tech_talks/",title:"Lunchtime Tech Talks",section:"Regular Events",content:` Lunchtime Tech Talks # The Research Engineering team meets for Lunchtime Tech Talks most Tuesdays over lunch. The talks start at 12:30.
At a tech talk someone (usually someone in REG) presents or discusses something, such as about a project or data science/computer science/software engineering topic. They can also be opportunities to look for help and input. We encourage talks at the beginning of projects (before it\u0026rsquo;s certain what exactly you\u0026rsquo;ll be doing) or to discuss a problem you\u0026rsquo;re unsure how to solve. We also have shorter format lightning talks, where several people give a shorter talk.
The Data Science Skills wiki contains the talks schedule, calendar invitation instructions and information on signing up for a talk.
`}),e.add({id:9,href:"/REG-handbook/docs/onboarding/new_joiners/",title:"New Joiners",section:"Onboarding",content:` New Joiners # This section helps new members of REG get up to speed. Please go through these page as one of the very first things when you join.
First Few Days Systems Set Up `}),e.add({id:10,href:"/REG-handbook/docs/regular_events/reading_groups/",title:"Reading Groups",section:"Regular Events",content:` Reading Groups # As part of projects or for general interest, members of the team create reading groups to learn about a topic. Reading groups may meet on weekly basis to discuss a chapter from a book, a paper, or to work together on implementing something.
A list of current reading groups and information about them can be found on the Data Science Skills wiki.
Material for the reading groups is stored in the Data Science Skills repository
There are also Turing Interest Groups and many other informal groups around the Turing.
`}),e.add({id:11,href:"/REG-handbook/docs/regular_events/",title:"Regular Events",section:"Docs",content:" Regular Events # Coffee Chats # Coffee Chats REG Events # Lunchtime tech talks Lightning talks Reading groups Outward-facing Events # Drop-in Sessions "}),e.add({id:12,href:"/REG-handbook/docs/communications/twitter/",title:"Twitter",section:"Communications",content:` Twitter # The group has a Twitter account @turinghut23. The purpose of the account is to have an informal public-facing channel where we can communicate about projects we are working on and about life as a research engineer at the Turing.
Access # If you want to tweet under the group account, ask the account controller for access.
This also gives you access to Medium
What to Post # Projects we work on (if public) Blog posts Talks that we organise Conferences and workshops Any public outputs — papers, published code etc. Please refer to the Turing\u0026rsquo;s social media policy when making posts.
`}),e.add({id:13,href:"/REG-handbook/docs/technical_practices/change_logs/",title:"Changelogs and Semantic Versioning",section:"Common Technical Practices",content:` Changelogs # For any non-trivial code, it is worth maintaining a Changelog. This is valuable as it is a record of changes from the perspective of users (rather than git commit messages which are often only meaningful to the developers involved). A recommended format for Changelog files is given at Keep a changelog. All notable changes to a project should be documented in this file.
Semantic Versioning # A related concept is semantic versioning. In most cases, semantic versioning is recommended. You should state explicitly whether or not you are using semantic versioning in both your project\u0026rsquo;s README and CHANGELOG files.
`}),e.add({id:14,href:"/REG-handbook/docs/how_we_work/defining-done/",title:"Defining Project Doneness",section:"How we work",content:` Defining Project Doneness # This working document was produced as part of Accelerating AI in the Arts and Humanities (AAAH).
As a Research Software Engineer, we often join a collaborative project when a code base already exists. Defining the aims of a collaboration can be challenging, and when there is limited time it is important to apply attention in the right places. The following document is designed to help:
Showcase what is important to us as RSEs Assessing the current status of an existing repo Define clear objectives Determine where to put effort Provide a common framework and language for collaborators Clearly define when the collaboration is done! The framework includes objectives that focus on improving the impact and legacy of the software, expanding communities of practice, and providing a confident codebase for future research.
For each project discuss with collaborators which \u0026ldquo;Level\u0026rdquo; in each of the following categories is a MINIMUM aim for defining done. Remember, time is a resource and so consider where efforts should be prioritised.
Reach and Robustness Level 01. Internal users: Identify how users already use the tool and its current issues. Level 02. Best practices: Address minimum code best practices with view to robustness and accessibility Level 03. External users: Identify how similar external users could use the tool and current barriers Level 04. Generalise: Identify how the tool could be made general and current barriers to that Level 05. Proof of concept: Demonstrate its use outside its original intended purpose/audience. Functionality Level 01. Standard use: Install the tool, try out a standard use case, write a demo if one doesn\u0026rsquo;t exist Level 02. Known Limitations: Understand and report. Level 03. Advanced use: Try out normal range but more advanced use cases, with edge cases. Level 04. New features: Identifying features for new functionality. Level 05. Enhancements: Fix functionality bugs and add features. Documentation Level 01. Follow docs: Follow the existing starting point of documentation (no help!) Level 02. What\u0026rsquo;s missing: Identify what documentation is missing: e.g. installation, optional arguments, licensing, diagrams/screenshots, future work, etc. Level 03. Write docs: Write the documentation in markdown files Level 04. Published: Release the documentation on GitPages etc Level 05. Walkthrough: Write walkthroughs/demos (also gifs or videos) Testing Level 01. Continous Integration Start the automated infrastructure Level 02. Defining Positive/Negative Cases Conversation about what are the expected outcomes/how the tool works Level 03. Automated User Tests End-to-end tests that check expected outcomes from above, black box Level 04. Fine-grain Tests/Unit Tests Focus on critical/pain points, remove brittleness, modularise and reuseable components Level 05. Error Reporting Focus on negative cases, informative error communication for external collaboration Open Release Level 01. Find barriers: Identify minimum criteria that need to be solved before public release e.g. authorship, sensitivity, licensing, publicity, timings Level 02. Solve barriers: Address the minimum criteria and milestone efforts Level 03. Release: Make the repo public. Level 04. Distribute: Release the repo on PiPY or CRAN or equivalent, include DOI Level 05. Publisise: Publish the repo with JOSS, and/or publicly present the work. `}),e.add({id:15,href:"/REG-handbook/docs/how_we_work/meeting_record/",title:"Meeting Records",section:"How we work",content:` Meeting Records # When a synchronous meeting is unavoidable, it is critical to produce a clear and thorough record.
The meeting record is important as a reference for what happened at the meeting. In particular, any decisions made or actions assigned need to be clearly recorded for future reference.
A good record will also be invaluable to anyone who was not able to attend an in person meeting.
Meeting Record Template # Below is a suggested template for a meeting record document. The template uses Pandoc Markdown. Parts of the template are already filled with explanations of how they should be used.
--- title: Short meeting title date: yyyy-mm-dd author: - List of authors of the this record abstract: | Summary of meeting purpose. Should help readers decide whether they need to read the record. keywords: [] # Pandoc LaTeX variables papersize: a4 fontfamily: fourier fontsize: 12pt colorlinks: true --- # Meeting Record ## Agenda 1. Itemised Agenda 1. Should be agreed in advance ## Present - List of people present ## Notes - Summary of discussion points - Use subsections if appropriate ## Decisions - Record any decisions made during the meeting ## Actions | Owner | Action | |-------|--------| | | | For printing or wider distribution, a meeting record following the template may be converted to pdf using Pandoc,
pandoc meeting_record.md -o meeting_record.pdf A Pandoc YAML metadata block at the top of the template contains metadata about the meeting and helps the record render into a good looking pdf document.
How To Use # Create the meeting record document before the meeting. Use a collaborative text editor like HackMD so that all attendees may edit the document. Circulate the document to allow others to add and agree on agenda items. Distribute the record or store in a location visible to everyone who may need to read it. The template may also be used to avoid a meeting entirely. The document can be completed collaboratively and asynchronously while achieving the same result.
`}),e.add({id:16,href:"/REG-handbook/docs/onboarding/",title:"Onboarding",section:"Docs",content:" Onboarding # "}),e.add({id:17,href:"/REG-handbook/docs/how_we_work/code_audits/",title:"Repo Audits",section:"How we work",content:` Repo Audits # As required we conduct audits of GitHub repositories created during projects. The aim is to check that the documentation is clear, installation is easy etc.
Audits should be conducted by people who have not worked on the project.
Past experience # These comments from running the first round of these in June 2021:
Installation is a big barrier for software with complex build requirements. We tried looking at two web app projects (Counterfactual Covid 19 and CROP) and despite Docker images being available we weren\u0026rsquo;t able to get them to build correctly. We might have had more success if all we needed to do was a pip or CRAN install.
First lesson: installation is ALWAYS harder than you think, and we need to get more fresh eyes on build instructions if we want our software to be easily usable. Second Lesson: Not having someone on hand from the project can be a big barrier, as we suspect there may have just been some small tweaks or changes that would fix our problem. One suggestion was to have a mix of unsupervised hacking and more knowledgeable feedback, maybe by having the person working on the project show up an hour in. If we can\u0026rsquo;t get someone who knows the project well to attend, at least have them available on Slack in case we get stuck. At the very least, we were able to document our issues on the repo, and in at least one case the project was able to make fixes. One suggestion is to encourage \u0026ldquo;Good First Issue\u0026rdquo; tags or \u0026ldquo;Hacktoberfest\u0026rdquo;-type tags that would help people know what simple things could be tackled in a few hours if they succeed in installing the software. I have found that it isn\u0026rsquo;t always straightforward to come up with such issues (I tried thinking of some for a previous iteration of the activity, but always got stuck when I realized I didn\u0026rsquo;t have a clue what to do and explaining the problem was hard enough), and in projects that are currently running it isn\u0026rsquo;t always easy to leave these uncompleted when you have more time to work on a project.
One idea was to have a HackMD document, similar to the one that suggests project meetings for new joiners to shadow, that lists all repos with such issues in one place, making it easier to find something fruitful to work on if these audits continue to be spontaneous.
An alternative is to make these non-spontaneous and schedule them in advance. We\u0026rsquo;ve kicked around the thought of scheduling lightning talks for all projects — perhaps we could better leverage people\u0026rsquo;s brains if we gave a lightning talk intro on Tuesday and then guided people through installing and hacking on the software the next day?
New joiners to projects inevitably spend a bunch of time doing exactly what we were trying to do in these sessions. Can we leverage the time investment of the new joiner by doubling up other team members to do this?
Should new joiners to the team be encouraged to do this for a couple of weeks before being assigned to a project? I had a few new joiners on one of the audit sessions, and they said it was a good way to learn more about the team and our projects.
`}),e.add({id:18,href:"/REG-handbook/docs/contributing/style_guide/",title:"Style Guide",section:"Contributing",content:` Style Guide # Semantic Line Breaks # It is encouraged to use Semantic Line Breaks when writing for the handbook. This improves the readability of source files and make diffs clearer. The Semantic Line Breaks specification explains the rules and reasoning. The most important rules are,
A semantic line break MUST occur after a sentence, as punctuated by a period (.), exclamation mark (!), or question mark (?). A semantic line break SHOULD occur after an independent clause as punctuated by a comma (,), semicolon (;), colon (:), or em dash (—). A semantic line break MAY occur after a dependent clause in order to clarify grammatical structure or satisfy line length constraints. Markdown # Whenever possible, the handbook\u0026rsquo;s prose should be written in Markdown rather than HTML. However, it is completely reasonable use HTML when it is needed. When it is advantageous, data should be stored in data files and processed using shortcodes rather than presented in raw Markdown.
Markdown styling is enforced by markdownlint using the configuration .mdl_style.rb . An explanation of the rules can be found here.
`}),e.add({id:19,href:"/REG-handbook/docs/contributing/creating_a_page/",title:"Adding New Content",section:"Contributing",content:` Adding New Content # How Hugo Arranges Content # Pages are build from content files in the content/ directory. Hugo automatically gives pages a URL based on the organisation of files in the content/ directory.
In Hugo, the first directory after content/ is significant and defines the content type. All handbook pages should be nested in the content/docs/ directory.
Sections may be created in content/docs/ (to any depth) by creating a directory containing a content file called _index.md.
It is important that the index file exists for Hugo to correctly assign pages to sections and for the theme to arrange pages in the tree-like menu. Creating a New Page # To create a new handbook page use the hugo new command.
hugo new content/docs/\u0026lt;path/to/page\u0026gt;.md If you wanted to create this page, you would type
hugo new content/docs/contributing/creating_a_page.md Hugo will create a new Markdown document at the path you specified.
Hugo provides a convenient way to new pages from templates called Archetypes. You can see the archetypes in the archetypes/ directory .
Because your document is in the docs directory, Hugo will look for an archetype called docs.md to use as a template.
Now you can edit your page with your favourite text editor. For example
vim content/docs/contributing/creating_a_page.md Creating a Section # We can also use the hugo new command to create a new section, both the directory and index file. For example
hugo new content/docs/new_section/_index.md vim content/docs/new_section/_index.md If you only want a section to organise some pages and not to have a page of its own, you can simply leave the content section of _index.md (after the YAML front matter) empty.
`}),e.add({id:20,href:"/REG-handbook/docs/how_we_work/",title:"How we work",section:"Docs",content:" How We Work # "}),e.add({id:21,href:"/REG-handbook/docs/projects/project_tracking/",title:"Project Tracking",section:"Projects",content:` Project Tracking # This page describes some of the tools we use for tracking projects and other tasks within the team.
Hut23 GitHub Repo # The Hut23 repo is the central hub for most team matters and admin.
Project Tracker: Board shows all upcoming, current and completed projects. There\u0026rsquo;s an issue for each project (see below). Depending on the project status, it will be in one column or another. In order to assign REG team members to projects, we use emojis to vote for the projects that we would be interested in taking part. You should react to all projects on the \u0026ldquo;Finding people\u0026rdquo; column, but also on the \u0026ldquo;Awaiting go/no-go\u0026rdquo; column. The voting system is as follows:
👍 Would be okay working on this project 👎 Would rather not work on this project 😄 Would really like to work on this project Issues: Each project has an issue following a common template, including a general description of a project and its current status, for example. There are also issues for service areas and other activities/organisational issues for the team.
Project Repos # All repos in the Turing organisation that REG have worked on should have the hut23 tag. So if you\u0026rsquo;re looking for something from a previous project searching for these tags may be a good place to start. Additionally, they should have a tag of the format hut23-123, where 123 is the issue number for that project in the Hut23 repo.
Forecast \u0026amp; Wimbledon # We use Forecast to track everyone\u0026rsquo;s allocations to projects. You can see which projects \u0026amp; service areas everyone in the team is currently involved in, as well as what they were allocated to in the past and will be allocated to in the future.
\u0026ldquo;Wimbledon planner\u0026rdquo; is an online version of a poster we previously had in the office to display the information in Forecast. It\u0026rsquo;s easier to see allocations for a longer period, and you can click project names to take you directly to the issue describing that project in the Hut23 repo.
`}),e.add({id:22,href:"/REG-handbook/docs/technical_practices/python/",title:"Python Tools and Practices",section:"Common Technical Practices",content:` Python Tools and Practices # Python is a widely used language within REG. Below are some useful tools to help you configure your repo (with links to examples).
Some of the topics discussed below are not exclusive to Python. As more content is added to the manual they should be separated out into their own pages. Autoformatters / Linters # There are many widely used autoformatter and linters for Python, which can be used as standalone tools or call from .pre-commit, continuous integration tools etc.:
isort Sorts your import statements correctly. The order isort \u0026ldquo;sorts\u0026rdquo; imports in the following order: standard library imports (e.g. import os). related third party imports (e.g. import pandas). local application/library specific imports (e.g. from .my_python_file import MyClass). You should put a blank line between each group of imports. the configuration of isort can be specified in a pyproject.toml file, where isort is using the [tool.isort] section. black A highly opinionated code formatter, which enforces control of minutiae details of your code. The configuration of black can be specified in a pyproject.toml file, where black is using the [tool.black] section. flake8 A wrapper for three other tools: PyFlakes — checks syntax, without checking the style. pycodestyle — checks compliance with PEP8 Ned Batchelder’s McCabe script — checks the cyclomatic complexity of code. Configuration can be specified in a .flake8 configuration file in the root directory of your project. It is possible to use all of these in combination. The ARC group have a repo with suggested configuration files which you can copy/adapt as required.
Type Checkers # Type checking is optional in Python but is generally recommended. There are several tools which can perform type checking:
mypy — This type-checker has the distinction of including Guido van Rossum in its core development team. pyright — By Microsoft. pytype — By Google. Automation (Pre-Commit \u0026amp; Actions) # A convenient way to incorporate many of these tools and checks into your workflow is to use pre-commit. Below is an example. You could adapt this to your needs, or create your own from the many hooks described in the documentation.
# See https://pre-commit.com for more information # See https://pre-commit.com/hooks.html for more hooks repos: - repo: https://github.com/pre-commit/pre-commit-hooks rev: v4.2.0 hooks: - id: trailing-whitespace - id: end-of-file-fixer - id: check-yaml - id: check-xml - id: check-json - id: pretty-format-json args: [--no-ensure-ascii, --no-sort-keys, --autofix] files: \u0026#34;.+json\u0026#34; - id: check-added-large-files - repo: https://github.com/psf/black rev: 22.3.0 hooks: - id: black # files: \u0026#34;*.py\u0026#34; exclude: \u0026#34;.+/ignore_this_legacy_file.py\u0026#34; - repo: https://github.com/pre-commit/mirrors-autopep8 rev: \u0026#39;v1.6.0\u0026#39; # Use the sha / tag you want to point at hooks: - id: autopep8 - repo: https://github.com/pre-commit/mirrors-mypy rev: \u0026#39;v0.960\u0026#39; # Use the sha / tag you want to point at hooks: - id: mypy exclude: \u0026#34;.+/ignore_this_legacy_file.py\u0026#34; - repo: https://github.com/pre-commit/mirrors-isort rev: v5.10.1 hooks: - id: isort This example checks:
There is no trailing whitespace at the end of each line. There is exactly one blank line at the end of the file. Any yaml files in the repo are formatted correctly. Any xml files in the repo are formatted correctly. Any json files in the repo are formatted correctly and \u0026ldquo;pretty printed\u0026rdquo;. If any large files have been added to the repo without using git-lfs Any python code (except the file named \u0026ldquo;ignore_this_legacy_file.py\u0026rdquo;), is formatted according to \u0026ldquo;black\u0026rsquo;s\u0026rdquo; uncompromising standard. Any python code (except the file named \u0026ldquo;ignore_this_legacy_file.py\u0026rdquo;), is formatted according to \u0026ldquo;pep8\u0026rsquo;s\u0026rdquo; standard. Any python code is tested for type safeness (That is declaring types is optional, but if types are declared they must be correct). The import statements in any python code are correctly ordered. If any of these tests fail or need to alter any files, the commit will fail. This prevents you from accidentally forgetting to check your changes before you commit them.
If you wish to run the checks in pre-commit without attempting to commit your changes:
pre-commit run --all-files There are many other possible checks available with pre-commit, which you can incorporate according to the needs of your project. The pre-commit documentation provides much more detail.
Testing tools # Some suggested testing tools:
A test framework pytest or the less fashionable unittest. Coverage reporting pytest-cov (a plugin for pytest) or coverage. A tool for testing code examples in your documentation doctest. This list of tools does not include a discussion on developing a testing strategy. Developing a testing strategy is a separate discussion, though it is not possible to make optimal use of these tools without a strategy.
`}),e.add({id:23,href:"/REG-handbook/docs/onboarding/new_joiners/systems_set_up/",title:"Systems Set Up",section:"New Joiners",content:` Systems Set Up # These are not hand-holding instructions. Rather they are a reference to help with your setup. If they are wrong or incomplete, please edit them. The page has been roughly organised into high priority things (do in your first couple of days), low priority (sometimes in the first couple of weeks), and reference.
If any of the material is unfamiliar (e.g. you haven\u0026rsquo;t seen a GitHub project board before), then please ask your buddies (or anyone else you meet in the group) to have an informal chat about it.
High priority # Getting a computer # Receive (or be assigned) new computer from IT. It will have an admin account for IT, and probably an account for you with a default password.
Log in with the password provided by IT.
Change your password.
Your new password should be strong (12 random characters), and ideally randomly generated by a password manager. Feel free to use a diceware-style passphrase.
Your password should be:
unique to the machine/system randomly generated (use a password generator) have an entropy of at least 64 bits, see wikipedia At least 11 characters if alphanumeric (use 12, though) At least 10 characters if alphanumeric plus symbols At least 5 words if using dice ware At this point you can also configure fingerprint authentication.
Make sure you have FileVault on.
You should be setup with local admin privileges. Contact IT if this isn\u0026rsquo;t the case.
Install Homebrew # We recommend using Homebrew as your Mac package manager. Currently IT installs Homebrew by default on our laptops under /usr/local/bin. However, in the long run this might create problems with the new M1 Macs we use. To see if this problem applies to you, run which brew in the terminal and check if that\u0026rsquo;s the location. Until this is fixed by IT, what we recommend is the following:
Uninstall the current version of Homebrew by running the following command in the terminal: sudo /bin/bash -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall.sh)\u0026quot; Install Homebrew again following the instructions on the website. This will install Homebrew under /opt/homebrew/bin/brew (you can check by entering which brew in the terminal to see the new location). Communication Channels # Most communication happens through Slack. More structured communication happens through GitHub. These two systems are the first things you should setup (once you\u0026rsquo;re on Slack it\u0026rsquo;s a lot easier to ask for help).
Slack # Install Slack:
brew install --cask slack Once installed join the Turing Slack. You can self-subscribe with your @turing.ac.uk email address.
Important channels to join:
You should be added to #general and #random by default. Ask anyone in the team to add you to the private channel #hut23. If you are a senior, please ask another senior to invite you to the REG senior’s Slack channel (#line-managers). GitHub # We use GitHub for most coordination.
To get access to the Turing GitHub, create a GitHub account (or use an existing one), then fill this form on Turing Complete with your GitHub handle (if you have access to Turing Complete). Then let the GitHub org controller know that you have done this and they can add you straight away.
Also check the Project tracker and Planning projects to get a feeling on what goes on. You\u0026rsquo;re supposed to use them as follows:
Use Project tracker to track official projects we are tasked with. This is where we express preferences for projects, with emojis. Project leads should be assigned to the relevant issue and are responsible for keeping the issue up to date. Check this section of the handbook for more details. Use Planning to track internal tasks, projects and ideas, from lunch topics to self or group-development to any other kind of thing. Office 365 account # Your Turing main account rests here. You get access to mail (Exchange), calendar, a shared drive, Office apps. Check that you can login, and change your password and configure MFA. Ask IT if in need for help.
Lower Priority # Here we have more information about how we use the high priority systems, and also other systems to explore.
Slack Channels # Turing is a large organisation and there are many other channels you may want to join. Some are purely social, some are related to programmes or projects. For example, #tps (for the closely aligned Tools, Practices and Systems programme), #kitchen-dropin, #social, #pubclub, #askaway, #azure, #jargon-buster, #interesting-events, #football. If you get interested in something just ask if there is a channel about it.
You may also want to add yourself to #hut23standup, which some of us use for automated standups of \u0026ldquo;About Us\u0026rdquo; questions. The purpose is to get to know other team members by answering a question three times a week. Geekbot should send you the next question at 10:30am on Mondays, Wednesdays and Fridays.
We also have an optional Geekbot standup for daily check-ins. This standup will ask you three questions each morning (\u0026ldquo;What did you do yesterday?\u0026rdquo;, \u0026ldquo;What will you do today?\u0026rdquo;, and \u0026ldquo;What are you finding challenging?\u0026rdquo;. (Responses are posted in the #hut23standup-tasks channel.)
Tips for using Geekbot:
You can report before/after Geekbot asks you by sending it a message from Slack, e.g. report About Us or report Daily Standup. The Slack channels containing the responses can generate a lot of notifications. You might want to turn off notifications, or alternatively mute the channel and check in on it manually instead. (Right-click on the channel name to do this.) You can customise the time of Geekbot\u0026rsquo;s questions. Send dashboard as a message to Geekbot and click the link it returns. From there, you can select a standup and the \u0026ldquo;My preferences\u0026rdquo; button will take you to the customisation page. (This setting may not be enabled on all standups.) You can export a list of your previous responses to a standup from the dashboard. Click on the \u0026ldquo;timeline\u0026rdquo; tab of the relevant standup, and from there you can select the participants and questions to export to a csv file. This is particularly useful when you have forgotten to fill in Harvest for a while and need the information from the daily standup! Other workspaces you could join:
The Society of Research Software Engineering has a website, Slack and email list. Their Slack workspace contains plenty of details about relevant events. Mailing Lists # The Newsletters \u0026amp; Mailings page on Turing Complete has a \u0026ldquo;Update Mailing Preferences\u0026rdquo; link to sign up to receive some internal newsletters/communication.
Harvest and Forecast # We use Harvest to (loosely) track our time, and Forecast to manage allocations to projects. Get in touch with the person in charge of researcher tool management to setup a meeting sometime in your first week.
Harvest is a time tracking app used to monitor the amount of time being dedicated to each project. The easiest way to get set up is to ask your Line Manager or another member of the team to invite you and make you admin. You can then add yourself as a team member to whichever projects you\u0026rsquo;re working on and start tracking your time. There is a page here which goes into more detail about where you should log different activities.
Cezanne HR # Our HR system is Cezanne HR. You can log onto this with your Turing credentials using the \u0026ldquo;Enterprise login\u0026rdquo; option. If \u0026ldquo;Enterprise login\u0026rdquo; does not work, email HR to fix it.
This system is used for:
Requesting annual leave. Recording days off due to illness etc.. Managing the objective setting and performance review process (after your probation period). Create a Public Profile on the Turing Website # Get in touch with the Web team. Send them an email with your biography and a profile picture attached. Remember to indicate that you are part of REG and they will create a profile for you on the Turing website.
Office 365 Groups # Make sure you are in the following Office365 / email groups (check with IT):
Research engineering Business team (for non-Research Associate staff) Research staff All Staff If you are a senior member of staff, ask a principal to get you added to the REG-senior-staff email list. End-of-month all business team meetings (Turing Catch-ups). These are sent out as recurring calendar events. You can either email governance to forward you the invite or find a member of the REG team that is invited and ask them to forward the invite. Turing Bulletin: This internal newsletter is sent out every Thursday evening. If you don\u0026rsquo;t receive it, you can sign up manually via Turing Complete. GitHub Pro and Professional IDEs # Turing employees can apply for free GitHub Pro accounts, and use these to get free educational licences for professional versions of many JetBrains products (e.g., PyCharm, IntelliJ, …)
Go to education.github.com and apply for the GitHub Teacher Toolbox GitHub will ask you to verify your affiliation with an academic institution. The Turing is not on their list, but you can still use it. You will need proof of employment - a screenshot of Cezanne or the top of your Turing contract (including start date) have worked for people in the past. Once GitHub have approved your Pro account, go to the JetBrains website and create an account there (sign in via GitHub) You can now apply for a free educational licence (\u0026ldquo;Apply for a free student or teacher license\u0026rdquo;) for professional versions of various IDEs. There is no obligation to use these IDEs, this is just an FYI in case you are interested. OneDrive # Sync the Research Engineering documents: From SharePoint, under \u0026ldquo;Research Engineering\u0026rdquo; private group, go to \u0026ldquo;Documents\u0026rdquo;, then \u0026ldquo;Sync\u0026rdquo;.
Please avoid locally editing files that are common and might be edited concurrently. In that case, opt to use the online version through Office 365.
HackMD # We sometimes use HackMD for shared documents. If you don\u0026rsquo;t have an account, signup for a free account here. We do not have a paid account for HackMD.
Skype for business # We don\u0026rsquo;t use skype that often, but this can be installed through the Self Service application. You will need an application-specific password.
If you want a phone number ask IT.
Mathison # Mathison is the Institute\u0026rsquo;s intranet. A few things still need to be done on the old intranet, Turing Complete.
Purchasing home office equipment # There is a budget to purchase peripherals (monitor, mouse, keyboard, etc.) as well as other equipment such as an office chair and desk. For peripherals, get in touch with IT Services. With regards to getting a chair and desk for your home office, you are welcome to purchase these yourself and claim back up to £200 for these items together. See guidance on Mathison on how to claim it back.
Reference # Take a look at the following sections:
Regular Events Common Technical Practices `}),e.add({id:24,href:"/REG-handbook/docs/onboarding/new_joiners/checklist/",title:"Checklist",section:"New Joiners",content:` Checklist # This page attempts to list all the things that a new starter should remember to do. It makes no guarantees of completeness, and attempts to list both compulsory things and optional ones. It has been written by new starters as they go. If you\u0026rsquo;ve recently started in REG and find yourself doing anything related to getting started, that others might want to do as well but that is not on this list, please add it. If anything is unclear, please figure it out by e.g. asking your buddies, and then clarify it here.
Meetings # Attend buddy meeting Attend HR induction Attend IT induction Meet with line manager Shadow meetings: https://hackmd.io/nnsWP4i_SiiwlT4meOeq6g (if you don\u0026rsquo;t have access, ask someone in charge of onboarding) Join in for welcome coffee(s) HR tasks # Complete Agenda screening (hopefully this happened already before you started, but if you haven\u0026rsquo;t received an email about this, ask HR) Do a bazillion things on Cezanne: Enter specific personal details, most important are: DOB Home address Emergency contact details Bank details NI Health form Additional characteristics form Complete and reupload in Cezanne documents area: “BL partners - Health, Safety and Security” form HMRC new starters form \u0026ldquo;Right to work\u0026rdquo; document Signed and dated scanned contract (can just upload the version signed with DocuSign before joining) British Library pass: \u0026ldquo;BL partners - Health, Safety and Security\u0026rdquo; form: complete and reupload in Cezanne documents area Upload photo to Documents section on Cezanne (where other starter forms are provided) HR require Agenda Screening report (no action if already completed Agenda Screening before starting) Temporary pass, line manager emails reception to request Send P45 from previous job to HR contact directly by email Read about health and dental insurance, decide whether to sign up Check the Turing Benefits site, to see if there are useful discounts there Send to HR for the next Turing Town Hall meeting: Casual photo Fun fact(s) Provide a description for the ATI webpage (https://alan-turing-institute.github.io/REG-handbook/docs/onboarding/new_joiners/systems_set_up#create-a-public-profile-on-the-turing-website) Verify your MoorePay account (for payslips). Verification email will be sent to you in your first month of employment. See Payroll and Payslip enquiries on Mathison for more information. GitHub and communications # Get access to private GitHub repos (fill in this form and send your GitHub username to the person responsible for GitHub (see The REGistry) to join the Alan Turing Organisation GitHub Join Turing Slack Go through public Slack channels, decide which ones to join Request account on Harvest and Forecast by asking the the person in charge of researcher tool management, or your buddies to get you set up (to clarify, it is one account but allows you sign in to both) https://alan-turing-institute.github.io/REG-handbook/docs/onboarding/new_joiners/systems_set_up#harvest-and-forecast Read through the REG handbook: https://alan-turing-institute.github.io/REG-handbook Read through the new starter page of the REG handbook: https://alan-turing-institute.github.io/REG-handbook/docs/onboarding/new_joiners/first_few_days/ Have a look at REG projects on the Project tracker in the Hut23 GitHub Repo. Read through the Project Tracking page to learn how we set our preferences for projects by using emojis, and start emoji-ing for the projects in the \u0026ldquo;Finding people\u0026rdquo; and \u0026ldquo;Awaiting go/no-go\u0026rdquo; columns. Have a look at the Service areas. There is no pressure to join one right away so you can take some time talking to people and finding an area that interests you. Add [[Shared REG Calendar]] to Outlook Familiarise yourself with how to Book Rooms Message IT (ITServices@turing.ac.uk) to upgrade Zoom account from Basic to Pro New computer set-up # https://github.com/alan-turing-institute/research-engineering-group/wiki/Moving-to-a-new-computer Ongoing activity sign-up # \u0026ldquo;Tech Talks\u0026rdquo; (Tuesdays 12:30pm), link on: https://github.com/alan-turing-institute/DataScienceSkills/wiki/Lunchtime-Tech-Talks `}),e.add({id:25,href:"/REG-handbook/docs/technical_practices/configuring_editors/",title:"Configuring Your Editor",section:"Common Technical Practices",content:` Configuring Your Editor # Many people will configure their editor to suit their own needs and preferences.
It is possible to do this so that there are common standards between collaborators in the code base, while allowing for differences in individuals\u0026rsquo; configurations.
Some of the topics discussed below are heavily focused on python development. In due course we should generalise this to cover other languages. General # Some common, particular formatting/encoding options can be configured for a range of editors/IDEs by using EditorConfig in your repo. A .editorconfig needs to be placed in the root of your repo.
Many (but not all) editors support EditorConfig files allowing different members of your project team to use their own favourite editor while maintaining common coding standards. Some editors support EditorConfig natively; others require a plugin to support EditorConfig.
There is some overlap in functionality between EditorConfig and Flake8. Crudely EditorConfig applies standards to files as they are created/edited, while Flake8 checks all files (irrespective of origin) on demand.
Both tools need to be set up en ensure that they are mutually compatible. However, since the configurations for both Flake8 and EditorConfig rarely change after the initial setup of the project, this is not a problem in practice.
VS code # VS Code Python documentation ARC suggested config (Turing members only) Extensions # Focusing on Python only, useful extensions include:
Python — adds core functionality for linting/navigating/debugging/etc. Pylance Jupyter Python Indent — improves editor behaviour for matching indentation across lines autoDocstring — auto-generate template docstrings IntelliCode — improved auto-completion/code suggestions Black formatter (pre-release) — auto-format code with black isort (pre-release) — auto-format code with isort Python Type Hint — helps with completing type-hints The black and isort pre-release packages are currently designed to work with the Python pre-release version. This is likely to be consolidated/improved in the future. Settings # VS Code Settings are stored in:
Global user settings: ~/Library/Application Support/Code/User/settings.json. Project-specific (Workspace) settings: \u0026lt;PROJECT_ROOT\u0026gt;/.vscode/settings.json. You can also customise most settings via the Code -\u0026gt; Preferences -\u0026gt; Settings menu. For Python specifically note the Extensions -\u0026gt; Python section.
Here\u0026rsquo;s an example config for Python (reliant on installing the extensions above):
{ \u0026#34;python.linting.flake8Enabled\u0026#34;: true, \u0026#34;python.linting.mypyEnabled\u0026#34;: true, \u0026#34;python.testing.pytestEnabled\u0026#34;: true, \u0026#34;python.linting.pylintEnabled\u0026#34;: true, \u0026#34;autoDocstring.docstringFormat\u0026#34;: \u0026#34;numpy\u0026#34;, \u0026#34;[python]\u0026#34;: { \u0026#34;editor.rulers\u0026#34;: [88], \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;ms-python.black-formatter\u0026#34;, \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;editor.codeActionsOnSave\u0026#34;: { \u0026#34;source.organizeImports\u0026#34;: true }, }, } It does the following:
Activates linting with flake8, mypy and pylint. We suggest using flake8 at a minimum, but you may not want all three activated as it gets quite noisy and there\u0026rsquo;s some overlap between them. Sets pytest to be the default test framework. Sets numpy to be the default format for docstrings generated with autoDocstring. Sets black to be the default formatter, and automatically runs black and isort when saving a file. Adds a vertical ruler to the editor at 88 characters (default line length used by black) for Python files only. Note that:
It\u0026rsquo;s possible to specify arguments for the linters/formatters in settings.json. We suggest using each tool\u0026rsquo;s own configuration files (e.g. .flake8), as these will then be picked up by other tools and editors as well. (e.g. Should configure flake8 and isort to be compatible with black). If enabled tools are not installed in your Python environment VS Code should prompt you to install them. You are likely to have some non-Python specific configuration as well, so add the settings above to your settings.json file rather than overwriting it completely. Selecting the Python Interpreter # VSC Python Interpreters Docs
For each workspace VS Code can be configured to use a specific Python interpreter (environment). That interpreter is then used by default when doing anything with your code (running scripts, linting, tests etc.)
To set the interpreter:
Open a .py file. Click on the details of the currently used environment on the status bar (bottom right). Select an interpreter from the list that appears (or write the path to it). Or from the command palette:
Cmd-Shift-P -\u0026gt; Search for \u0026ldquo;Python: Select Interpreter\u0026rdquo;. Linting # VSC Linting Docs
If linters are activated (see Settings) they will be run after saving a file, and any problems the enabled tools encounter will be highlighted in-line in the editor, and be listed in the \u0026ldquo;Problems\u0026rdquo; tab of the panel at the bottom (or select View -\u0026gt; Problems from the menu).
Hovering over a piece of code with a problem in the editor will give you more details about it, and may have a \u0026ldquo;Quick Fix\u0026rdquo; available, which will edit the code for you to fix it.
Formatting # VSC Formatting Docs
VS code can use a few different file formatters (e.g. black, yapf, autopep8 — we recommend black), which can be configured to run automatically when saving files (see settings above) or with the following shortcuts:
Option-Shift-F. Save the file (if auto-formatting is configured). Right-click in a Python editor -\u0026gt; Format Document. Cmd-Shift-P (Opens Command Palette) -\u0026gt; Search for \u0026ldquo;format\u0026rdquo; -\u0026gt; \u0026ldquo;Format Document\u0026rdquo;. Running Tests # VSC Testing Docs
If you have enabled pytest (or another framework, e.g. unittest), tests will be discovered and appear in the Testing menu (lab bottle on the left side menu).
From here you can run all/individual tests. You can also search for \u0026ldquo;Tests\u0026rdquo; in the command palette (Cmd-Shift-P) to find options for running tests. If a test fails, clicking on it will show the error message. You can also debug tests (see debugging).
If you have a tests file open in an editor the latest pass/fail status of a test will be shown (or a play button if the test hasn\u0026rsquo;t run before) — running tests can be triggered from there too.
Debugging # VSC Debugging Docs
Other Tips and Tricks # Auto-import: If you start typing a function name that hasn\u0026rsquo;t been imported, VS Code will pop up a list of suggested functions and \u0026ldquo;Auto-Import\u0026rdquo; them (add an import statement to the top of the script) if you select one of them. Rename symbol: Right-clicking on a (variable/function/class/etc.) name in a file, selecting \u0026ldquo;Rename symbol\u0026rdquo;, and entering a new name will change the name of all instances of that across your codebase (but respecting the scope of the renamed entity). Jupyter: The Python extension comes with a Jupyter extension so you can run and edit notebooks in VS Code. Personally, I prefer the native Jupyter notebook/lab interface to the VS Code one. AutoDocstring: If the AutoDocstring extension is installed, typing \u0026quot;\u0026quot;\u0026quot; then hitting enter will generate a template docstring for you containing placeholders for all arguments (including their types if type hints are used in the function definition). Go to definition: Right-clicking on a (variable/function/class/etc.) name and selecting \u0026ldquo;Go to definition\u0026rdquo; will take you to where that thing is defined in the codebase. Git: The editor highlights modifications to the code (by the line numbers), and you can also commit etc. from VS Code using the Source Control menu on the left. Docker: There are extensions (1, 2) for running code in containers/attaching a VS code window to a container. `}),e.add({id:26,href:"/REG-handbook/docs/contributing/editing_a_page/",title:"Editing a Page",section:"Contributing",content:` Editing a Page # If you followed the instructions in the Getting Started section to checkout the repository and serve the handbook locally you can edit a page locally. However, as you may have noticed, at the bottom of each page is a link to edit the page in the GitHub web editor if you would prefer. This may be easy for making small changes.
Pages # Each page is a Markdown file with YAML front matter followed by the page contents in Markdown.
Front Matter # The front matter is used to define various pieces of metadata related to a page. The front matter appears at the top of a content file. In the handbook we format front matter as YAML, preceded and followed by three hyphens.
--- title: \u0026#34;Example Page\u0026#34; weight: 1 --- The full YAML specification is long and comprehensive. The most important thing to understand here is that the front matter YAML consists of keys and values separated by a hyphen. For example, in the expression weight: 1, weight is the key with a value of 1.
If you created a page using hugo new then some boilerplate front matter with explanatory comments should already be present. If you are editing an existing page there should already be front matter.
Most of the time, the only keys you will need to consider are title and weight.
title The title of a page as it appears in the navigation menu weight Determines the order of pages in the navigation menu. Smaller numbers appear first The Hugo documentation details a set of predefined front matter keys. Other valid fields related to the handbook theme are documented in the theme\u0026rsquo;s README.
Content # After the front matter is the content section.
--- title: \u0026#34;Example Page\u0026#34; weight: 1 --- | content section | The content section is formatted in Markdown. Markdown Guide outlines the basic and extended.
Not all of the extended Markdown syntax may be implemented by Hugo\u0026rsquo;s Markdown renderer Shortcodes # Shortcodes are templates (which can be parametrised) and included the content section. They can be particularly useful for including more complex features than Markdown\u0026rsquo;s simple syntax will allow. Using a shortcode is preferable to including raw HTML in a content file.
Shortcodes can called in Markdown content files the following way
{{% shortcode parameter %}} Some shortcodes may have an opening and closing tag, similar to HTML
{{% shortcode %}} content to process {{% /shortcode %}} Hugo Shortcodes # Hugo has a set of useful built-in shortcodes.
In particular
figure gist highlight param ref and relref Theme Shortcodes # The theme has a number of shortcodes which may be helpful.
In particular
hints expand KaTeX tabs Repository Shortcodes # Shortcodes can be included in the handbooks repository. For more information see Creating Shortcodes
repo_link # Create a link to a file or directory in the handbook\u0026rsquo;s repository.
{{% repo_link path=\u0026#34;README.md\u0026#34; text=\u0026#34;README\u0026#34; %}} path Path to the file or directory relative to the root of the repository text Text of the link (can include Markdown formatting) `}),e.add({id:27,href:"/REG-handbook/docs/projects/",title:"Projects",section:"Docs",content:` Projects # This section describes how we coordinate our project work.
It does not go into details of how individual projects are managed, but how REG coordinates its commitments to the range of projects it\u0026rsquo;s involved in.
`}),e.add({id:28,href:"/REG-handbook/docs/technical_practices/",title:"Common Technical Practices",section:"Docs",content:` Common Technical Practices # This section contains a section of common technical practices within REG. For many of the topics in this section, there may be many possible ways to achieve the same goal — which are debated at length elsewhere. The intention of this section is not to claim that any of the methods here are the \u0026ldquo;best\u0026rdquo; (however defined). Merely that they are good enough to allow the reader to focus on other, more interesting, unique or important, aspects of their project.
`}),e.add({id:29,href:"/REG-handbook/docs/contributing/contributing_changes/",title:"Contributing Changes",section:"Contributing",content:` Contributing Changes # Once you have made changes, you will need to contribute them back to the remote repository. This page explains the process of pushing your changes back to the remote, and how your contribution will be checked in the CI and review process.
Currently, reviews are not required. Pull requests may be merged by anyone with write access when all required CI checks pass.
You may enable auto-merge on a pull request so that a merge is made as soon as all checks pass.
The handbook users the GitHub flow workflow. In short
create a branch make changes open pull request review merge to main This workflow should help changes be deployed quickly.
When making commits, it is a good idea to follow Tim Pope\u0026rsquo;s recommendations for good commit messages. Creating a Branch # You should make your changes on a new branch, and not on main. This will make it easier to merge changes from many contributors. Try to pick a branch name which is short and describes the change you are making.
The changes on one branch or pull request should address a single issue and be self-contained. Don\u0026rsquo;t try to solve more than one unrelated problem at once.
Sticking to this practice will help ensure pull requests are small and easy to review. Otherwise, you might end up having to make many changes during review, have difficultly keeping your branch up to date or upset the reviewers.
Opening a Pull Request # When you think your changes are ready to be merged, open a pull request. If you don\u0026rsquo;t want your changes to be merged yet but would like some feedback, you can open a draft pull request.
When you open a pull request you will be presented with a template. Complete the sections and answer the questions as best you can. In particular, make sure to reference any issues your work closes or is related to.
Continuous Integration # A series of tests will be automatically conducted on each commit and pull request. The tests are defined in ci.yaml .
The following tests are required to pass before merging a pull request
A Markdown linter A Hugo build There are other test that are not required before merging, although you should aim to pass all tests. Those are
A Markdown link checker A HTML proofer (including link checking) on the output of Hugo Keeping Your Branch up to Date # The branch protection rules applied to main will prevent merging out-of-date branches. This means if your branch doesn\u0026rsquo;t include the changes from the HEAD of origin/main it won\u0026rsquo;t be possible to merge it.
If your branch isn\u0026rsquo;t up to date, you can fix it with a merge or rebase.
Merging # Merging the changes from origin/main is probably the simpler way to get your branch up to date. It will leave the Git history a bit messier which can bother some people.
Ensure you have the latest changes on origin/main in your local repository
git fetch Merge origin/main into your branch. If your branch was called my_branch you would run
git switch my_branch git merge origin/main Git will notify you of any conflicts. If there are conflicts you should fix them before running git merge --continue to commit.
After you are done you can push your changes.
Rebasing # Rebasing your branch on top of origin/main can make conflicts more difficult or confusing to deal with.
Ensure you have the latest changes on origin/main in your local repository
git fetch Apply your commits on top of origin/main. If your branch was called my_branch you would run
git switch my_branch git rebase origin/main If you want to tidy up your commits or messages you might want to use git rebase -i.
Git will notify you of any conflicts. If there are conflicts you will need to fix them iteratively, running git rebase --continue to apply each commit.
When the rebase is done, you will need to force push your changes as you have rewritten the history of your branch.
git push -f Rewriting history is considered impolite on a branch where you are working collaboratively. It can cause problems when the state of a remote changes unexpectedly. The Review Process # Once your pull request has been submitted the handbook maintainers will be prompted to make a review. Each pull request requires at least one approval from the maintainers before merging. If a reviewer requests any changes or makes any comments, these must be resolved before the pull request can be merged.
`}),e.add({id:30,href:"/REG-handbook/docs/technical_practices/software_dev_best_practice/",title:"Software Development",section:"Common Technical Practices",content:` Software Development Best Practices # Status: this document is a draft proposal.
RSE projects # There should be a Github issue for each thing we do. It’s ok for issues to evolve and my preference would be that the top description box always has the most up to date, clearest description of the issue and its definition of done. Feel free to make liberal use of the comments for communication and tracking investigative / exploratory work. The main description box should contain a clear definition of done / acceptance criteria sufficient for the following to be done in principle by different people from the team who are involved in the project.
Implement the functionality Write tests to validate the implementation meets the definition of done Review the implementation for correctness All code should have automated tests, with all tests runnable by a single command by someone who has checked out a fresh copy of the repo.
All dependencies, installation, compilation etc should be scripted such that these can be triggered by a single command by someone who has checked out a fresh copy of the repo. Dependencies required only for testing can require a second command or few.
Each new issue should be developed on a short-lived feature branch split from “main”. These branches ideally only live around 0.5-2 days before being merged back into main. Merge process should be: merge main into feature branch and resolve any conflicts. Push latest feature branch to Github. Open PR to merge into main after review + continuous integration (CI) tests.
Code should be committed regularly in small chunks. You should generally be committing multiple times per day. Commits on feature branches can have broken functionality or tests, but all merges into main should only occur at commits where the code is correct and has passing tests.
All code commits should be accompanied by tests verifying it behaves as expected. At a minimum code submitted as a PR should have tests that show it meets the definition of done defined in the related issue(s). However, code should have additional unit / regression / integration tests where appropriate (it’s almost always appropriate). Writing code then tests is a significantly lower quality assurance measure than writing tests first / in iteration with the code, so you should do the latter.
All code should have had two eyeballs on it before it is merged into main, either through pair programming or code review within the PR. Please note on the PR who two eyes were. The second pair of eyes can be anyone on the project (not just a coder), anyone in our team or someone from a related team (e.g. the UCL research programming). Whether as pair programming or a code review, the final PR code should be validated against the definition of done detailed in the related issue(s) by the two pairs of eyes.
The Github repository should be set up to run all tests on all pushes to all branches and on all PRs. Currently this can be done for public repos via GitHub Actions. If CI is set up this way, commits to main should be blocked unless all tests pass.
Data Science projects # TBD
`}),e.add({id:31,href:"/REG-handbook/docs/communications/",title:"Communications",section:"Docs",content:" Communications # "}),e.add({id:32,href:"/REG-handbook/docs/contributing/reviewing_changes/",title:"Reviewing Changes",section:"Contributing",content:` Reviewing Changes # The review process helps to ensure high quality and catch problems in contributions. When acting as a reviewer, you should see your position as sharing your knowledge and working with the contributors to achieve the best possible result. Reviewing should not be an adversarial process.
Code Quality # As a reviewer, one of your jobs is to ensure the quality of the codebase remains high.
The CI process will help to assess pull requests by subjecting each commit to a series of tests. Some tests are required to pass and will block merging until they do.
Other tests are allowed to fail. This is because these tests check external hyperlinks which can fail for reasons out of our control. For example, a website being offline or a rate limiting API. However, you should always aim to have all tests passing and investigate why any test fails. In particular, a genuinely incorrect link should not be ignored.
You should always clone the branch, build the handbook locally (using hugo server --minify) and inspect the changes using your browser. Not all bugs will be caught by CI and not all changes will be obvious in the source files.
Reviewing the Pull Request # Use the GitHub review system to check the diffs of all source files.
You should make use of line comments where you have comments or questions about particular lines of sections. This gives context so that everyone knows where the problem is or what the question refers to.
Line comments can also be used to suggest changes (using the ± button). You should do this when you have a simple solution. This is an excellent way to share knowledge.
When you are finished, submit your review making sure to choose \u0026ldquo;comment\u0026rdquo;, \u0026ldquo;approve\u0026rdquo; or \u0026ldquo;request changes\u0026rdquo; as appropriate.
Changes # If you request changes, the pull request will enter an iterative process where the contributors make adjustments you repeat the review process.
The contributors may accept your proposed changes, make their own changes or push back against changes. All of these may be appropriate. It is important to work together with the contributors to resolve any conversations. All conversations must be resolved before merging.
Merging # Update your review status to \u0026ldquo;approve\u0026rdquo; when you are happy with the state of the pull request. When all reviewers are satisfied, merge the pull request.
`}),e.add({id:33,href:"/REG-handbook/docs/contributing/advanced/",title:"Advanced",section:"Contributing",content:` Advanced # Using Data # Through using templates Hugo can build page content from datafiles. This is particularly useful for when you want to display structured data in a page and when it would be easier to maintain a datafile rather than a Markdown or HTML document.
Creating Shortcodes # It is possible to create your own shortcodes. These should be placed in layouts/shortcodes/ .
If you feel the need to use HTML or want to create page content from a datafile (like a YAML file or csv) then a shortcode is probably the right answer.
You should refer to Hugo\u0026rsquo;s templates and functions documentation for resources to help writing a shortcode.
Partial Templates # Whole page templates are built from of a number of smaller partial templates. This approach reduces repeated code in templates and help keep making changes simple.
The theme defines a number of dummy partial templates for us to overwrite.
For example, the Creative Commons notice at the bottom of each page was added by editing layouts/partial/docs/inject/footer.html .
`}),e.add({id:34,href:"/REG-handbook/docs/contributing/",title:"Contributing",section:"Docs",content:` Contributing # This section contains a guide for contributing to the handbook. It is not a comprehensive guide to Hugo or any of the other tools used. Instead it is aimed to be a user-focused guide explaining how add to or edit the handbook without dwelling on the details of the underlying technologies. For those interesting in learning more, links will be liberally placed throughout for further reading.
`})})()