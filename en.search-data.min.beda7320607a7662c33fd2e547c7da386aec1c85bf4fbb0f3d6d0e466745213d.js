'use strict';(function(){const t={cache:!0};t.doc={id:'id',field:['title','content'],store:['title','href','section']};const e=FlexSearch.create('balance',t);window.bookSearchIndex=e,e.add({id:0,href:'/REG-handbook/docs/contributing/discussions_and_issues/',title:"Discussions and Issues",section:"Contributing",content:" Discussions and Issues # Contributing does not only mean adding code or writing pages. Being involved in reporting issues and discussing ideas are important and valuable aspects to contributing. The handbook uses both issues and discussions on GitHub.\nDiscussions # The handbook Dicussions are the best place for informal talk about the handbook.\nYou should feel welcome to create a discussion on any relevant topic, without the formality of an issue.\nGood examples of discussions are\nAny questions Possible bugs (does anyone else have this problem?) Chapter suggestions Looking for collaborators Community support Any other on-topic talk Issues # The issue tracker is best used for development work. This is because issues integrate well with GitHub development tools like projects, pull requests, assignments and so on.\nEach issue should ideally represent a well-defined, self-contained piece of work suitable to become a single pull request.\nGood examples of issues are\nBug reports with technical detail Developed chapter proposals Feature requests (such as new shortcodes) Specific ideas for changes When opening an issue, pick a suitable template (if any) to make the process easier.\n"}),e.add({id:1,href:'/REG-handbook/docs/technical_practices/',title:"Common Technical Practises",section:"Docs",content:" Common Technical Practises # This section contains a section of common technical practises within REG. For many of the topics in this section, there may be many possible ways to achieve the same goal - which are debated at length elsewhere. The intention of this section is not to claim that any of the methods here are the \u0026ldquo;best\u0026rdquo; (however defined). Merely that they are good enough to allow the reader to focus on other, more interesting, unique or important, aspects of their project.\n"}),e.add({id:2,href:'/REG-handbook/docs/contributing/',title:"Contributing",section:"Docs",content:" Contributing # This section contains a guide for contributing to the handbook. It is not a comprehensive guide to Hugo or any of the other tools used. Instead it is aimed to be a user-focused guide explaining how add to or edit the handbook without dwelling on the details of the underlying technologies. For those interesting in learning more, links will be liberally placed throughout for further reading.\n"}),e.add({id:3,href:'/REG-handbook/docs/contributing/getting_started/',title:"Getting Started",section:"Contributing",content:" Getting Started # Install dependencies # To contribute to the handbook you will need\nGit Hugo (You will need the extended version with Sass/SCSS support) Your favourite text editor You might also find it helpful to install markdownlint so that you can lint your branch before making a pull request.\nThe linting style used is included in the root of the repository, .mdl_style.rb.\nClone the repository # Clone the repository with one of the following options (depending on how you authenticate with GitHub):\nSSH authentication git clone --recurse-submodules git@github.com:alan-turing-institute/REG-handbook.git cd REG-handbook HTTPS authentication git clone --recurse-submodules https://github.com/alan-turing-institute/REG-handbook.git cd REG-handbook The --recurse-submodules flag is important as the handbook\u0026rsquo;s theme is included as a Git submodule\nServe the handbook locally # While working on the handbook, it will be useful to preview your changes locally. To do this use Hugo\u0026rsquo;s server command\nhugo server --minify In the output of this command will be a line similar to\nWeb Server is available at http://localhost:1313/REG-handbook/ (bind address 127.0.0.1) which contains the URL of the locally served site. Navigate to this address in your browser to preview the handbook.\nThe Hugo server will monitor the files in the repository and automatically rebuild the site whenever you make changes. This is a useful tool to immediately view your changes.\n"}),e.add({id:4,href:'/REG-handbook/docs/how_we_work/',title:"How we work",section:"Docs",content:" How We Work # "}),e.add({id:5,href:'/REG-handbook/docs/how_we_work/meeting_record/',title:"Meeting Records",section:"How we work",content:" Meeting Records # When a synchronous meeting is unavoidable, it is critical to produce a clear and thorough record.\nThe meeting record is important as a reference for what happened at the meeting. In particular, any decisions made or actions assigned need to be clearly recorded for future reference.\nA good record will also be invaluable to anyone who was not able to attend an in person meeting.\nMeeting Record Template # Below is a suggested template for a meeting record document. The template uses Pandoc Markdown. Parts of the template are already filled with explanations of how they should be used.\n--- title: Short meeting title date: yyyy-mm-dd author: - List of authors of the this record abstract: | Summary of meeting purpose. Should help readers decide whether they need to read the record. keywords: [] # Pandoc LaTeX variables papersize: a4 fontfamily: fourier fontsize: 12pt colorlinks: true --- # Meeting Record ## Agenda 1. Itemised Agenda 1. Should be agreed in advance ## Present - List of people present ## Notes - Summary of discussion points - Use subsections if appropriate ## Decisions - Record any decisions made during the meeting ## Actions | Owner | Action | |-------|--------| | | | For printing or wider distribution, a meeting record following the template may be converted to pdf using Pandoc,\npandoc meeting_record.md -o meeting_record.pdf A Pandoc YAML metadata block at the top of the template contains metadata about the meeting and helps the record render into a good looking pdf document.\nHow To Use # Create the meeting record document before the meeting. Use a collaborative text editor like HackMD so that all attendees may edit the document. Circulate the document to allow others to add and agree on agenda items. Distribute the record or store in a location visible to everyone who may need to read it. The template may also be used to avoid a meeting entirely. The document can be completed collaboratively and asynchronously while achieving the same result.\n"}),e.add({id:6,href:'/REG-handbook/docs/communications/twitter/',title:"Twitter",section:"Communications",content:" Twitter # The group has a Twitter account @turinghut23. The purpose of the account is to have an informal public-facing channel where we can communicate about projects we are working on and about life as a research engineer at the Turing.\nAccess # If you want to tweet under the group account, ask the account controller for access.\nThis also gives you access to Medium\nWhat to Post # Projects we work on (if public) Blog posts Talks that we organise Conferences and workshops Any public outputs - papers, published code etc. Please refer to the Turing\u0026rsquo;s social media policy\n"}),e.add({id:7,href:'/REG-handbook/docs/technical_practices/change_logs/',title:"Changelogs and Semantic Versioning",section:"Common Technical Practises",content:" Changelogs # For any non-trivial code, it is worth maintaining a Changelog.\nThis is valuable as it is a record of changes from the perspective of users (rather than git commit messages which are often only meaningful to the developers involved).\nA recommended format for Changelog files is given at Keep a changelog.\nAll notable changes to a project should be documented in this file.\nSemantic Versioning # A related concept is semantic versioning.\nIn most cases, semantic versioning is recommended. You should state explicitly whether or not you are using semantic versioning in both your project\u0026rsquo;s README and CHANGELOG files.\n"}),e.add({id:8,href:'/REG-handbook/docs/communications/',title:"Communications",section:"Docs",content:" Communications # "}),e.add({id:9,href:'/REG-handbook/docs/contributing/style_guide/',title:"Style Guide",section:"Contributing",content:" Style Guide # Semantic Line Breaks # It is encouraged to use Semantic Line Breaks when writing for the handbook. This improves the readability of source files and make diffs clearer. The Semantic Line Breaks specification explains the rules and reasoning. The most important rules are,\nA semantic line break MUST occur after a sentence, as punctuated by a period (.), exclamation mark (!), or question mark (?). A semantic line break SHOULD occur after an independent clause as punctuated by a comma (,), semicolon (;), colon (:), or em dash (—). A semantic line break MAY occur after a dependent clause in order to clarify grammatical structure or satisfy line length constraints. Markdown # Whenever possible, the handbook\u0026rsquo;s prose should be written in Markdown rather than HTML. However, it is completely reasonable use HTML when it is needed. When it is advantageous, data should be stored in data files and processed using shortcodes rather than presented in raw Markdown.\nMarkdown styling is enforced by markdownlint using the configuration .mdl_style.rb . An explanation of the rules can be found here.\n"}),e.add({id:10,href:'/REG-handbook/docs/contributing/creating_a_page/',title:"Adding New Content",section:"Contributing",content:" Adding New Content # How Hugo Arranges Content # Pages are build from content files in the content/ directory. Hugo automatically gives pages a URL based on the organisation of files in the content/ directory.\nIn Hugo, the first directory after content/ is significant and defines the content type. All handbook pages should be nested in the content/docs/ directory.\nSections may be created in content/docs/ (to any depth) by creating a directory containing a content file called _index.md.\nIt is important that the index file exists for Hugo to correctly assign pages to sections and for the theme to arrange pages in the tree-like menu. Creating a New Page # To create a new handbook page use the hugo new command.\nhugo new content/docs/\u0026lt;path/to/page\u0026gt;.md If you wanted to create this page, you would type\nhugo new content/docs/contributing/creating_a_page.md Hugo will create a new Markdown document at the path you specified.\nHugo provides a convenient way to new pages from templates called Archetypes. You can see the archetypes in the archetypes/ directory .\nBecause your document is in the docs directory, Hugo will look for an archetype called docs.md to use as a template.\nNow you can edit your page with your favourite text editor. For example\nvim content/docs/contributing/creating_a_page.md Creating a Section # We can also use the hugo new command to create a new section, both the directory and index file. For example\nhugo new content/docs/new_section/_index.md vim content/docs/new_section/_index.md If you only want a section to organise some pages and not to have a page of its own, you can simply leave the content section of _index.md (after the YAML front matter) empty.\n"}),e.add({id:11,href:'/REG-handbook/docs/technical_practices/python/',title:"Python tools and practises",section:"Common Technical Practises",content:" Python tools and practices # Python is a widely used language within REG. Below are some useful tools to help you configure your repo (with links to examples).\nNote: Some of the topics discussed below are not exclusive to Python. As more content is added to the manual they should be separated out into their own pages.\nAutoformatters / Linters # There are many widely used autoformatter and linters for Python, which can be used as standalone tools or call from .pre-commit, continuous integration tools etc:\nisort Sorts your import statements correctly. The order isort \u0026ldquo;sorts\u0026rdquo; imports in the following order: standard library imports (e.g. import os) related third party imports (e.g. import pandas) local application/library specific imports (e.g. from .my_python_file import MyClass) You should put a blank line between each group of imports. the configuration of isort can be specified in a pyproject.toml file, where isort is using the [tool.isort] section. black A highly opinionated code formatter, which enforces control of minutiae details of your code. the configuration of black can be specified in a pyproject.toml file, where black is using the [tool.black] section. flake8 A wrapper for three other tools: PyFlakes - checks syntax, without checking the style. pycodestyle - checks compliance with PEP8 Ned Batchelder’s McCabe script - checks the cyclomatic complexity of code. configuration can be specified in a .flake8 configuration file in the root directory of your project. It is possible to use all of these in combination. For Turing members only, the ARC group have a repo with suggested configuration files which you can copy/adapt as required.\nType checkers # Type checking is optional in Python but is generally recommended. There are several tools which can perform type checking:\nmypy - This type-checker has the distinction of including Guido van Rossum in its core development team. pyright - By Microsoft. pytype - By Google. Currently, no opinion is offered in selecting between these tools.\nJupyter Notebooks # Python-based Jupyter Notebooks are widely used within REG. There are some specific considerations when applying coding standards to notebooks.\nDetails to be added.\nAutomation (pre-commit \u0026amp; actions) # A convenient way to incorporate many of these tools and checks into your workflow is to use pre-commit. Below is an example. You could adapt this to your needs, or create your own from the many hooks described in the documentation.\n# See https://pre-commit.com for more information # See https://pre-commit.com/hooks.html for more hooks repos: - repo: https://github.com/pre-commit/pre-commit-hooks rev: v4.2.0 hooks: - id: trailing-whitespace - id: end-of-file-fixer - id: check-yaml - id: check-xml - id: check-json - id: pretty-format-json args: [--no-ensure-ascii, --no-sort-keys, --autofix] files: \u0026#34;.+json\u0026#34; - id: check-added-large-files - repo: https://github.com/psf/black rev: 22.3.0 hooks: - id: black # files: \u0026#34;*.py\u0026#34; exclude: \u0026#34;.+/ignore_this_legacy_file.py\u0026#34; - repo: https://github.com/pre-commit/mirrors-autopep8 rev: \u0026#39;v1.6.0\u0026#39; # Use the sha / tag you want to point at hooks: - id: autopep8 - repo: https://github.com/pre-commit/mirrors-mypy rev: \u0026#39;v0.960\u0026#39; # Use the sha / tag you want to point at hooks: - id: mypy exclude: \u0026#34;.+/ignore_this_legacy_file.py\u0026#34; - repo: https://github.com/pre-commit/mirrors-isort rev: v5.10.1 hooks: - id: isort This example checks:\nThere is no trailing whitespace at the end of each line. There is exactly one blank line at the end of the file. Any yaml files in the repo are formatted correctly. Any xml files in the repo are formatted correctly. Any json files in the repo are formatted correctly and \u0026ldquo;pretty * printed\u0026rdquo;. If any large files have been added to the repo without using git* -lfs Any python code (except the file named \u0026ldquo;ignore_this_legacy_file.p* y\u0026rdquo;), is formatted according to \u0026ldquo;black\u0026rsquo;s\u0026rdquo; uncompromising standard. Any python code (except the file named \u0026ldquo;ignore_this_legacy_file.p* y\u0026rdquo;), is formatted according to \u0026ldquo;pep8\u0026rsquo;s\u0026rdquo; standard. Any python code is tested for type safeness (That is declaring ty* pes is optional, but if types are declared they must be correct). The import statements in any python code are correctly ordered. If any of these tests (a) fail or (b) need to alter any files, the commit will fail. This prevents you from accidentally forgetting to check your changes before you commit them.\nIf you wish to run the checks in pre-commit without attempting to commit your changes:\npre-commit run --all-files There are many other possible checks available with pre-commit, which you can incorporate according to the needs of your project. The pre-commit documentation provides much more detail.\nRepeating your pre-commit test in GitHub Actions\nDeployment and packaging # There are a range of ways to make python software available for distribution. Which combination of tools and processes you use depends on the particular aims of your project.\nIn due course, details to be added here, including:\nGH Actions setup.py vs poetry Publishing to PyPI Publishing to conda-forge What should trigger a deployment? (eg every commit to main, tag-commit, etc) Single sourcing package version number Testing tools # Some suggested testing tools:\nA test framework [pytest] or the less fashionable unittest Coverage reporting pytest-cov (a plugin for pytest) or coverage A tool for testing code examples in your documentation doctest This list of tools does not include a discussion on developing a testing strategy. Developing a testing strategy is a separate discussion, though it is not possible to make optimal use of these tools without a strategy.\n"}),e.add({id:12,href:'/REG-handbook/docs/technical_practices/configuring_editors/',title:"Configuring your code editor",section:"Common Technical Practises",content:" Configuring your code editor # Many people will configure their editor to suit their own needs and preferences.\nIt is possible to do this so that there are common standards between collaborators in the code base, whilst allowing for differences in individuals\u0026rsquo; configurations.\nNote: Some of the topics discussed below are heavily focused on python development. In due course we should generalise this to cover other languages.\nGeneral # Some common particular formatting/encoding options can be configured for a range of editors/IDEs, by using EditorConfig in your repo. A .editorconfig needs to be placed in the root of your repo.\nMany (but not all) editors support EditorConfig files, allowing different members of your project team to use their own favourite editor, whilst maintaining common coding standards. Some support EditorConfig natively, others require a plugin to support EditorConfig.\nThere is some overlap in functionality between EditorConfig and Flake8. Crudely EditorConfig applies standards to files as they are created/edited, whilst Flake8 checks all files (irrespective of origin) on demand.\nBoth tools need to be set up en ensure that they are mutually compatible. However, since the configurations for both Flake8 and EditorConfig rarely change after the initial setup of the project, this is not a problem in practice.\nVS code # VS Code Python documentation ARC suggested config (Turing members only) Extensions # Focusing on Python only, useful extensions include:\nPython - adds core functionality for linting/navigating/debugging/etc. Pylance Jupyter Python Indent - improves editor behaviour for matching indentation across lines autoDocstring - auto-generate template docstrings IntelliCode - improved auto-completion/code suggestions Black formatter (pre-release) - auto-format code with black isort (pre-release) - auto-format code with isort Python Type Hint - helps with completing type-hints NB: The black and isort pre-release packages are currently designed to work with the Python pre-release version. This is likely to be consolidated/improved in the future.\nSettings # VS Code Settings are stored in:\nGlobal user settings: ~/Library/Application Support/Code/User/settings.json Project-specific (Workspace) settings: \u0026lt;PROJECT_ROOT\u0026gt;/.vscode/settings.json You can also customise most settings via the Code -\u0026gt; Preferences -\u0026gt; Settings menu. For Python specifically note the Extensions -\u0026gt; Python section.\nHere\u0026rsquo;s an example config for Python (reliant on installing the extensions above):\n{ \u0026#34;python.linting.flake8Enabled\u0026#34;: true, \u0026#34;python.linting.mypyEnabled\u0026#34;: true, \u0026#34;python.testing.pytestEnabled\u0026#34;: true, \u0026#34;python.linting.pylintEnabled\u0026#34;: true, \u0026#34;autoDocstring.docstringFormat\u0026#34;: \u0026#34;numpy\u0026#34;, \u0026#34;[python]\u0026#34;: { \u0026#34;editor.rulers\u0026#34;: [88], \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;ms-python.black-formatter\u0026#34;, \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;editor.codeActionsOnSave\u0026#34;: { \u0026#34;source.organizeImports\u0026#34;: true }, }, } It does the following:\nActivates linting with flake8, mypy and pylint I\u0026rsquo;d suggest using flake8 at a minimum, but you may not want all three activated as it gets quite noisy and there\u0026rsquo;s some overlap between them. Sets pytest to be the default test framework. Sets numpy to be the default format for docstrings generated with autoDocstring. Sets black to be the default formatter, and automatically runs black and isort when saving a file. Adds a vertical ruler to the editor at 88 characters (default line length used by black) for Python files only. Note that:\nIt\u0026rsquo;s possible to specify arguments for the linters/formatters in settings.json, but I\u0026rsquo;d suggest using each tool\u0026rsquo;s own configuration files (e.g. .flake8), as these will then be picked up by other tools and editors as well. (e.g. Should configure flake8 and isort to be compatible with black). If enabled tools are not installed in your Python environment VS Code should prompt you to install them. You are likely to have some non-Python specific configuration as well, so add the settings above to your settings.json file rather than overwriting it completely. Selecting Python interpreter # VSC Python Interpreters Docs\nFor each workspace VS Code can be configured to use a specific Python interpreter (environment). That interpreter is then used by default when doing anything with your code (running scripts, linting, tests etc.)\nTo set the interpreter:\nOpen a .py file Click on the details of the currently used environment on the status bar (bottom right) Select an interpreter from the list that appears (or write the path to it) Or from the command palette:\nCmd-Shift-P -\u0026gt; Search for \u0026ldquo;Python: Select Interpreter\u0026rdquo; Linting # VSC Liniting Docs\nIf linters are activated (see Settings) they will be run after saving a file, and any problems the enabled tools encounter will be highlighted in-line in the editor, and be listed in the \u0026ldquo;Problems\u0026rdquo; tab of the panel at the bottom (or select View -\u0026gt; Problems from the menu).\nHovering over a piece of code with a problem in the editor will give you more details about it, and may have a \u0026ldquo;Quick Fix\u0026rdquo; available, which will edit the code for you to fix it.\nFormatting # VSC Formatting Docs\nVS code can use a few different file formatters (e.g. black, yapf, autopep8 - we recommend black), which can be configured to run automatically when saving files (see settings above) or with the following shortcuts:\nOption-Shift-F Save the file (if auto-formatting is configured) Right-click in a Python editor -\u0026gt; Format Document Cmd-Shift-P (Opens Command Palette) -\u0026gt; Search for \u0026ldquo;format\u0026rdquo; -\u0026gt; \u0026ldquo;Format Document\u0026rdquo; Running tests # VSC Testing Docs\nIf you have enabled pytest (or another framework, e.g. unittest), tests will be discovered and appear in the Testing menu (lab bottle on the left side menu).\nFrom here you can run all/individual tests. You can also search for \u0026ldquo;Tests\u0026rdquo; in the command palette (Cmd-Shift-P) to find options for running tests. If a test fails, clicking on it will show the error message. You can also debug tests (see debugging).\nIf you have a tests file open in an editor the latest pass/fail status of a test will be shown (or a play button if the test hasn\u0026rsquo;t run before) - running tests can be triggered from there too.\nDebugging # VSC Debugging Docs\nDetails to be added.\nOther tips and tricks # Auto-import: If you start typing a function name that hasn\u0026rsquo;t been imported, VS Code will pop up a list of suggested functions and \u0026ldquo;Auto-Import\u0026rdquo; them (add an import statement to the top of the script) if you select one of them. Rename symbol: Right-clicking on a (variable/function/class/etc.) name in a file, selecting \u0026ldquo;Rename symbol\u0026rdquo;, and entering a new name will change the name of all instances of that across your codebase (but respecting the scope of the renamed entity). Jupyter: The Python extension comes with a Jupyter extension so you can run and edit notebooks in VS Code. Personally, I prefer the native Jupyter notebook/lab interface to the VS Code one. AutoDocstring: If the AutoDocstring extension is installed, typing \u0026quot;\u0026quot;\u0026quot; then hitting enter will generate a template docstring for you containing placeholders for all arguments (including their types if type hints are used in the function definition). Go to definition: Right-clicking on a (variable/function/class/etc.) name and selecting \u0026ldquo;Go to definition\u0026rdquo; will take you to where that thing is defined in the codebase. Git: The editor highlights modifications to the code (by the line numbers), and you can also commit etc. from VS Code using the Source Control menu on the left. Docker: There are extensions (1, 2) for running code in containers/attaching a VS code window to a container. Vim # Details to be added\n"}),e.add({id:13,href:'/REG-handbook/docs/contributing/editing_a_page/',title:"Editing a Page",section:"Contributing",content:" Editing a Page # If you followed the instructions in the Getting Started section to checkout the repository and serve the handbook locally you can edit a page locally. However, as you may have noticed, at the bottom of each page is a link to edit the page in the GitHub web editor if you would prefer. This may be easy for making small changes.\nPages # Each page is a Markdown file with YAML front matter followed by the page contents in Markdown.\nFront Matter # The front matter is used to define various pieces of metadata related to a page. The front matter appears at the top of a content file. In the handbook we format front matter as YAML, preceded and followed by three hyphens.\n--- title: \u0026#34;Example Page\u0026#34; weight: 1 --- The full YAML specification is long and comprehensive. The most important thing to understand here is that the front matter YAML consists of keys and values separated by a hyphen. For example, in the expression weight: 1, weight is the key with a value of 1.\nIf you created a page using hugo new then some boilerplate front matter with explanatory comments should already be present. If you are editing an existing page there should already be front matter.\nMost of the time, the only keys you will need to consider are title and weight.\ntitle The title of a page as it appears in the navigation menu weight Determines the order of pages in the navigation menu. Smaller numbers appear first The Hugo documentation details a set of predefined front matter keys. Other valid fields related to the handbook theme are documented in the theme\u0026rsquo;s README.\nContent # After the front matter is the content section.\n--- title: \u0026#34;Example Page\u0026#34; weight: 1 --- | content section | The content section is formatted in Markdown. Markdown Guide outlines the basic and extended.\nNot all of the extended Markdown syntax may be implemented by Hugo\u0026rsquo;s Markdown renderer Shortcodes # Shortcodes are templates (which can be parametrised) and included the content section. They can be particularly useful for including more complex features than Markdown\u0026rsquo;s simple syntax will allow. Using a shortcode is preferable to including raw HTML in a content file.\nShortcodes can called in Markdown content files the following way\n{{% shortcode parameter %}} Some shortcodes may have an opening and closing tag, similar to HTML\n{{% shortcode %}} content to process {{% /shortcode %}} Hugo Shortcodes # Hugo has a set of useful built-in shortcodes.\nIn particular\nfigure gist highlight param ref and relref Theme Shortcodes # The theme has a number of shortcodes which may be helpful.\nIn particular\nhints expand KaTeX tabs Repository Shortcodes # Shortcodes can be included in the handbooks repository. For more information see Creating Shortcodes\nrepo_link # Create a link to a file or directory in the handbook\u0026rsquo;s repository.\n{{% repo_link path=\u0026#34;README.md\u0026#34; text=\u0026#34;README\u0026#34; %}} path Path to the file or directory relative to the root of the repository text Text of the link (can include Markdown formatting) "}),e.add({id:14,href:'/REG-handbook/docs/contributing/contributing_changes/',title:"Contributing Changes",section:"Contributing",content:" Contributing Changes # Once you have made changes, you will need to contribute them back to the remote repository. This page explains the process of pushing your changes back to the remote, and how your contribution will be checked in the CI and review process.\nCurrently, reviews are not required. Pull requests may be merged by anyone with write access when all required CI checks pass.\nYou may enable auto-merge on a pull request so that a merge is made as soon as all checks pass.\nThe handbook users the GitHub flow workflow. In short\ncreate a branch make changes open pull request review merge to main This workflow should help changes be deployed quickly.\nWhen making commits, it is a good idea to follow Tim Pope\u0026rsquo;s recommendations for good commit messages. Creating a Branch # You should make your changes on a new branch, and not on main. This will make it easier to merge changes from many contributors. Try to pick a branch name which is short and describes the change you are making.\nThe changes on one branch or pull request should address a single issue and be self-contained. Don\u0026rsquo;t try to solve more than one unrelated problem at once.\nSticking to this practice will help ensure pull requests are small and easy to review. Otherwise, you might end up having to make many changes during review, have difficultly keeping your branch up to date or upset the reviewers.\nOpening a Pull Request # When you think your changes are ready to be merged, open a pull request. If you don\u0026rsquo;t want your changes to be merged yet but would like some feedback, you can open a draft pull request.\nWhen you open a pull request you will be presented with a template. Complete the sections and answer the questions as best you can. In particular, make sure to reference any issues your work closes or is related to.\nContinuous Integration # A series of tests will be automatically conducted on each commit and pull request. The tests are defined in ci.yaml .\nThe following tests are required to pass before merging a pull request\nA Markdown linter A Hugo build There are other test that are not required before merging, although you should aim to pass all tests. Those are\nA Markdown link checker A HTML proofer (including link checking) on the output of Hugo Keeping Your Branch up to Date # The branch protection rules applied to main will prevent merging out-of-date branches. This means if your branch doesn\u0026rsquo;t include the changes from the HEAD of origin/main it won\u0026rsquo;t be possible to merge it.\nIf your branch isn\u0026rsquo;t up to date, you can fix it with a merge or rebase.\nMerging # Merging the changes from origin/main is probably the simpler way to get your branch up to date. It will leave the Git history a bit messier which can bother some people.\nEnsure you have the latest changes on origin/main in your local repository\ngit fetch Merge origin/main into your branch. If your branch was called my_branch you would run\ngit switch my_branch git merge origin/main Git will notify you of any conflicts. If there are conflicts you should fix them before running git merge --continue to commit.\nAfter you are done you can push your changes.\nRebasing # Rebasing your branch on top of origin/main can make conflicts more difficult or confusing to deal with.\nEnsure you have the latest changes on origin/main in your local repository\ngit fetch Apply your commits on top of origin/main. If your branch was called my_branch you would run\ngit switch my_branch git rebase origin/main If you want to tidy up your commits or messages you might want to use git rebase -i.\nGit will notify you of any conflicts. If there are conflicts you will need to fix them iteratively, running git rebase --continue to apply each commit.\nWhen the rebase is done, you will need to force push your changes as you have rewritten the history of your branch.\ngit push -f Rewriting history is considered impolite on a branch where you are working collaboratively. It can cause problems when the state of a remote changes unexpectedly. The Review Process # Once your pull request has been submitted the handbook maintainers will be prompted to make a review. Each pull request requires at least one approval from the maintainers before merging. If a reviewer requests any changes or makes any comments, these must be resolved before the pull request can be merged.\n"}),e.add({id:15,href:'/REG-handbook/docs/contributing/reviewing_changes/',title:"Reviewing Changes",section:"Contributing",content:" Reviewing Changes # The review process helps to ensure high quality and catch problems in contributions. When acting as a reviewer, you should see your position as sharing your knowledge and working with the contributors to achieve the best possible result. Reviewing should not be an adversarial process.\nCode Quality # As a reviewer, one of your jobs is to ensure the quality of the codebase remains high.\nThe CI process will help to assess pull requests by subjecting each commit to a series of tests. Some tests are required to pass and will block merging until they do.\nOther tests are allowed to fail. This is because these tests check external hyperlinks which can fail for reasons out of our control. For example, a website being offline or a rate limiting API. However, you should always aim to have all tests passing and investigate why any test fails. In particular, a genuinely incorrect link should not be ignored.\nYou should always clone the branch, build the handbook locally (using hugo server --minify) and inspect the changes using your browser. Not all bugs will be caught by CI and not all changes will be obvious in the source files.\nReviewing the Pull Request # Use the GitHub review system to check the diffs of all source files.\nYou should make use of line comments where you have comments or questions about particular lines of sections. This gives context so that everyone knows where the problem is or what the question refers to.\nLine comments can also be used to suggest changes (using the ± button). You should do this when you have a simple solution. This is an excellent way to share knowledge.\nWhen you are finished, submit your review making sure to choose \u0026ldquo;comment\u0026rdquo;, \u0026ldquo;approve\u0026rdquo; or \u0026ldquo;request changes\u0026rdquo; as appropriate.\nChanges # If you request changes, the pull request will enter an iterative process where the contributors make adjustments you repeat the review process.\nThe contributors may accept your proposed changes, make their own changes or push back against changes. All of these may be appropriate. It is important to work together with the contributors to resolve any conversations. All conversations must be resolved before merging.\nMerging # Update your review status to \u0026ldquo;approve\u0026rdquo; when you are happy with the state of the pull request. When all reviewers are satisfied, merge the pull request.\n"}),e.add({id:16,href:'/REG-handbook/docs/contributing/advanced/',title:"Advanced",section:"Contributing",content:" Advanced # Using Data # Through using templates Hugo can build page content from datafiles. This is particularly useful for when you want to display structured data in a page and when it would be easier to maintain a datafile rather than a Markdown or HTML document.\nCreating Shortcodes # It is possible to create your own shortcodes. These should be placed in layouts/shortcodes/ .\nIf you feel the need to use HTML or want to create page content from a datafile (like a YAML file or csv) then a shortcode is probably the right answer.\nYou should refer to Hugo\u0026rsquo;s templates and functions documentation for resources to help writing a shortcode.\nPartial Templates # Whole page templates are built from of a number of smaller partial templates. This approach reduces repeated code in templates and help keep making changes simple.\nThe theme defines a number of dummy partial templates for us to overwrite.\nFor example, the Creative Commons notice at the bottom of each page was added by editing layouts/partial/docs/inject/footer.html .\n"})})()